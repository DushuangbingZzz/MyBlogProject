{
	"posts": [{
			"id": "1",
			"title": "带你用vue撸后台 系列一（基础篇）",
			"author": {
				"name": "duppers",
				"profilePicture": "/images/authors/zhangsan.png"
			},
			"date": "2024-09-01T10:00:00Z",
			"content":"<h2>目录结构</h2><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">├── build                      // 构建相关&nbsp;&nbsp;</div><div class=\"ql-code-block\" data-language=\"plain\">├── config                     // 配置相关</div><div class=\"ql-code-block\" data-language=\"plain\">├── src                        // 源代码</div><div class=\"ql-code-block\" data-language=\"plain\">│&nbsp;&nbsp; ├── api                    // 所有请求</div><div class=\"ql-code-block\" data-language=\"plain\">│&nbsp;&nbsp; ├── assets                 // 主题 字体等静态资源</div><div class=\"ql-code-block\" data-language=\"plain\">│&nbsp;&nbsp; ├── components             // 全局公用组件</div><div class=\"ql-code-block\" data-language=\"plain\">│&nbsp;&nbsp; ├── directive              // 全局指令</div><div class=\"ql-code-block\" data-language=\"plain\">│&nbsp;&nbsp; ├── filtres                // 全局 filter</div><div class=\"ql-code-block\" data-language=\"plain\">│&nbsp;&nbsp; ├── icons                  // 项目所有 svg icons</div><div class=\"ql-code-block\" data-language=\"plain\">│&nbsp;&nbsp; ├── lang                   // 国际化 language</div><div class=\"ql-code-block\" data-language=\"plain\">│&nbsp;&nbsp; ├── mock                   // 项目mock 模拟数据</div><div class=\"ql-code-block\" data-language=\"plain\">│&nbsp;&nbsp; ├── router                 // 路由</div><div class=\"ql-code-block\" data-language=\"plain\">│&nbsp;&nbsp; ├── store                  // 全局 store管理</div><div class=\"ql-code-block\" data-language=\"plain\">│&nbsp;&nbsp; ├── styles                 // 全局样式</div><div class=\"ql-code-block\" data-language=\"plain\">│&nbsp;&nbsp; ├── utils                  // 全局公用方法</div><div class=\"ql-code-block\" data-language=\"plain\">│&nbsp;&nbsp; ├── vendor                 // 公用vendor</div><div class=\"ql-code-block\" data-language=\"plain\">│&nbsp;&nbsp; ├── views                   // view</div><div class=\"ql-code-block\" data-language=\"plain\">│&nbsp;&nbsp; ├── App.vue                // 入口页面</div><div class=\"ql-code-block\" data-language=\"plain\">│&nbsp;&nbsp; ├── main.js                // 入口 加载组件 初始化等</div><div class=\"ql-code-block\" data-language=\"plain\">│   └── permission.js          // 权限管理</div><div class=\"ql-code-block\" data-language=\"plain\">├── static                     // 第三方不打包资源</div><div class=\"ql-code-block\" data-language=\"plain\">│&nbsp;&nbsp; └── Tinymce                // 富文本</div><div class=\"ql-code-block\" data-language=\"plain\">├── .babelrc                   // babel-loader 配置</div><div class=\"ql-code-block\" data-language=\"plain\">├── eslintrc.js                // eslint 配置项</div><div class=\"ql-code-block\" data-language=\"plain\">├── .gitignore                 // git 忽略项</div><div class=\"ql-code-block\" data-language=\"plain\">├── favicon.ico                // favicon图标</div><div class=\"ql-code-block\" data-language=\"plain\">├── index.html                 // html模板</div><div class=\"ql-code-block\" data-language=\"plain\">└── package.json               // package.json</div></div><p>这里来简单讲一下src文件</p><h3>api 和 views</h3><p>简单截取一下公司后台项目，现在后台大概有四五十个 api 模块</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/5/3/591e388437a8aea99794b175b1098389~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\"></p><p>如图可见模块有很多，而且随着业务的迭代，模块还会会越来越多。 所以这里建议根据业务模块来划分 views，并且 将views 和 api 两个模块一一对应，从而方便维护。如下图：</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/5/3/c185f7d37a268a1ff4044ff60f5341c0~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\"></p><p><br></p><p>如 article 模块下放的都是文章相关的 api，这样不管项目怎么累加，api和views的维护还是清晰的，当然也有一些全区公用的api模块，如七牛upload，remoteSearch等等，这些单独放置就行。</p><h3>components</h3><p>这里的 components 放置的都是全局公用的一些组件，如上传组件，富文本等等。一些页面级的组件建议还是放在各自views文件下，方便管理。如图：</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/5/3/a355aa4081709f7d9fecf6dfaf08129d~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\"></p><p><br></p><h3>store</h3><p>这里我个人建议不要为了用 vuex 而用 vuex。就拿我司的后台项目来说，它虽然比较庞大，几十个业务模块，几十种权限，但业务之间的耦合度是很低的，文章模块和评论模块几乎是俩个独立的东西，所以根本没有必要使用 vuex 来存储data，每个页面里存放自己的 data 就行。当然有些数据还是需要用 vuex 来统一管理的，如登录token,用户信息，或者是一些全局个人偏好设置等，还是用vuex管理更加的方便，具体当然还是要结合自己的业务场景的。总之还是那句话，不要为了用vuex而用vuex！</p><h2>webpack</h2><blockquote>这里是用 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue-cli\" rel=\"noopener noreferrer\" target=\"_blank\">vue-cli</a> 的 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs-templates%2Fwebpack\" rel=\"noopener noreferrer\" target=\"_blank\">webpack-template</a> 为基础模板构建的，如果你对这个有什么疑惑请自行google，相关的配置绍其它的文章已经介详细了，这里就不再展开了。简单说一些需要注意到地方。</blockquote><h3>jquery (本项目已移除)</h3><p>管理后台不同于前台项目，会经常用到一些第三方插件，但有些插件是不得不依赖 jquery 的，如市面很多富文本基都是依赖 jquery 的，所以干脆就直接引入到项目中省事(gzip之后只有34kb，而且常年from cache,不要考虑那些吹毛求疵的大小问题，这几kb和提高的开发效率根本不能比)。但是如果第三方库的代码中出现<img src=\"https://juejin.cn/equation?tex=.xxx%E6%88%96jQuery.xxx%E6%88%96window.jQuery%E6%88%96window.\" alt=\".xxx或jQuery.xxx或window.jQuery或window.\">则会直接报错。要达到类似的效果，则需要使用 webpack 内置的 <code>ProvidePlugin</code> 插件，配置很简单，只需要</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">new webpack.ProvidePlugin({</div><div class=\"ql-code-block\" data-language=\"plain\">  $: 'jquery' ,</div><div class=\"ql-code-block\" data-language=\"plain\">  'jQuery': 'jquery'</div><div class=\"ql-code-block\" data-language=\"plain\">})</div></div><p>这样当 webpack 碰到 require 的第三方库中出现全局的$、jQeury和window.jQuery 时，就会使用 node_module 下 jquery 包 export 出来的东西了。</p><h3>alias</h3><p>当项目逐渐变大之后，文件与文件直接的引用关系会很复杂，这时候就需要使用<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fresolve%2F\" rel=\"noopener noreferrer\" target=\"_blank\">alias</a> 了。 有的人喜欢alias 指向src目录下，再使用相对路径找文件</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">resolve: {</div><div class=\"ql-code-block\" data-language=\"plain\">  alias: {</div><div class=\"ql-code-block\" data-language=\"plain\">    '~': resolve(__dirname, 'src')</div><div class=\"ql-code-block\" data-language=\"plain\">  }</div><div class=\"ql-code-block\" data-language=\"plain\">}</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">//使用</div><div class=\"ql-code-block\" data-language=\"plain\">import stickTop from '~/components/stickTop'</div></div><p>或者也可以</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">alias: {</div><div class=\"ql-code-block\" data-language=\"plain\">  'src': path.resolve(__dirname, '../src'),</div><div class=\"ql-code-block\" data-language=\"plain\">  'components': path.resolve(__dirname, '../src/components'),</div><div class=\"ql-code-block\" data-language=\"plain\">  'api': path.resolve(__dirname, '../src/api'),</div><div class=\"ql-code-block\" data-language=\"plain\">  'utils': path.resolve(__dirname, '../src/utils'),</div><div class=\"ql-code-block\" data-language=\"plain\">  'store': path.resolve(__dirname, '../src/store'),</div><div class=\"ql-code-block\" data-language=\"plain\">  'router': path.resolve(__dirname, '../src/router')</div><div class=\"ql-code-block\" data-language=\"plain\">}</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">//使用</div><div class=\"ql-code-block\" data-language=\"plain\">import stickTop from 'components/stickTop'</div><div class=\"ql-code-block\" data-language=\"plain\">import getArticle from 'api/article'</div></div><p>没有好与坏对与错，纯看个人喜好和团队规范。</p><h2>ESLint</h2><p>不管是多人合作还是个人项目，代码规范是很重要的。这样做不仅可以很大程度地避免基本语法错误，也保证了代码的可读性。这所谓工欲善其事，必先利其器，个人推荐 eslint+vscode 来写 vue，绝对有种飞一般的感觉。效果如图：</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/5/3/709326a6df695ff7b92ba4c4d6ff7d71~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\" alt=\"eslintGif.gif\"></p><p>每次保存，vscode就能标红不符合eslint规则的地方，同时还会做一些简单的自我修正。安装步骤如下：</p><p><br></p><p>首先安装eslint插件</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/5/3/2c4a6510d1a0c8a4086ea99daccf9b2d~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\" alt=\"eslint1.png\"></p><p><br></p><p>安装并配置完成 ESLint 后，我们继续回到 VSCode 进行扩展设置，依次点击 文件 &gt; 首选项 &gt; 设置 打开 VSCode 配置文件,添加如下配置</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">    \"files.autoSave\":\"off\",</div><div class=\"ql-code-block\" data-language=\"plain\">    \"eslint.validate\": [</div><div class=\"ql-code-block\" data-language=\"plain\">       \"javascript\",</div><div class=\"ql-code-block\" data-language=\"plain\">       \"javascriptreact\",</div><div class=\"ql-code-block\" data-language=\"plain\">       \"html\",</div><div class=\"ql-code-block\" data-language=\"plain\">       {&nbsp;\"language\":&nbsp;\"vue\",&nbsp;\"autoFix\":&nbsp;true&nbsp;}</div><div class=\"ql-code-block\" data-language=\"plain\">     ],</div><div class=\"ql-code-block\" data-language=\"plain\">     \"eslint.options\": {</div><div class=\"ql-code-block\" data-language=\"plain\">        \"plugins\": [\"html\"]</div><div class=\"ql-code-block\" data-language=\"plain\">     }</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div></div><p>这样每次保存的时候就可以根据根目录下.eslintrc.js你配置的eslint规则来检查和做一些简单的fix。这里提供了一份我平时的eslint规则<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FPanJiaChen%2Fvue-element-admin%2Fblob%2Fmaster%2F.eslintrc.js\" rel=\"noopener noreferrer\" target=\"_blank\">地址</a>，都简单写上了注释。每个人和团队都有自己的代码规范，统一就好了，去打造一份属于自己的eslint 规则上传到npm吧，如饿了么团队的 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Feslint-config-elemefe\" rel=\"noopener noreferrer\" target=\"_blank\">config</a>，vue的 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Feslint-config-vue\" rel=\"noopener noreferrer\" target=\"_blank\">config</a>。</p><p><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FvarHarrie%2FDawn-Blossoms%2Fissues%2F10\" rel=\"noopener noreferrer\" target=\"_blank\">vscode 插件和配置推荐</a></p><h2>封装 axios</h2><p>我们经常遇到一些线上 的bug，但测试环境很难模拟。其实可以通过简单的配置就可以在本地调试线上环境。 这里结合业务封装了axios ，<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FPanJiaChen%2Fvue-element-admin%2Fblob%2Fmaster%2Fsrc%2Futils%2Frequest.js\" rel=\"noopener noreferrer\" target=\"_blank\">线上代码</a></p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">import axios from 'axios'</div><div class=\"ql-code-block\" data-language=\"plain\">import { Message } from 'element-ui'</div><div class=\"ql-code-block\" data-language=\"plain\">import store from '@/store'</div><div class=\"ql-code-block\" data-language=\"plain\">import { getToken } from '@/utils/auth'</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">// 创建axios实例</div><div class=\"ql-code-block\" data-language=\"plain\">const service = axios.create({</div><div class=\"ql-code-block\" data-language=\"plain\">  baseURL: process.env.BASE_API, // api的base_url</div><div class=\"ql-code-block\" data-language=\"plain\">  timeout: 5000 // 请求超时时间</div><div class=\"ql-code-block\" data-language=\"plain\">})</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">// request拦截器</div><div class=\"ql-code-block\" data-language=\"plain\">service.interceptors.request.use(config =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">  // Do something before request is sent</div><div class=\"ql-code-block\" data-language=\"plain\">  if (store.getters.token) {</div><div class=\"ql-code-block\" data-language=\"plain\">    config.headers['X-Token'] = getToken() // 让每个请求携带token--['X-Token']为自定义key 请根据实际情况自行修改</div><div class=\"ql-code-block\" data-language=\"plain\">  }</div><div class=\"ql-code-block\" data-language=\"plain\">  return config</div><div class=\"ql-code-block\" data-language=\"plain\">}, error =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">  // Do something with request error</div><div class=\"ql-code-block\" data-language=\"plain\">  console.log(error) // for debug</div><div class=\"ql-code-block\" data-language=\"plain\">  Promise.reject(error)</div><div class=\"ql-code-block\" data-language=\"plain\">})</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">// respone拦截器</div><div class=\"ql-code-block\" data-language=\"plain\">service.interceptors.response.use(</div><div class=\"ql-code-block\" data-language=\"plain\">  response =&gt; response,</div><div class=\"ql-code-block\" data-language=\"plain\">  /**</div><div class=\"ql-code-block\" data-language=\"plain\">  * 下面的注释为通过response自定义code来标示请求状态，当code返回如下情况为权限有问题，登出并返回到登录页</div><div class=\"ql-code-block\" data-language=\"plain\">  * 如通过xmlhttprequest 状态码标识 逻辑可写在下面error中</div><div class=\"ql-code-block\" data-language=\"plain\">  */</div><div class=\"ql-code-block\" data-language=\"plain\">  //  const res = response.data;</div><div class=\"ql-code-block\" data-language=\"plain\">  //     if (res.code !== 20000) {</div><div class=\"ql-code-block\" data-language=\"plain\">  //       Message({</div><div class=\"ql-code-block\" data-language=\"plain\">  //         message: res.message,</div><div class=\"ql-code-block\" data-language=\"plain\">  //         type: 'error',</div><div class=\"ql-code-block\" data-language=\"plain\">  //         duration: 5 * 1000</div><div class=\"ql-code-block\" data-language=\"plain\">  //       });</div><div class=\"ql-code-block\" data-language=\"plain\">  //       // 50008:非法的token; 50012:其他客户端登录了;  50014:Token 过期了;</div><div class=\"ql-code-block\" data-language=\"plain\">  //       if (res.code === 50008 || res.code === 50012 || res.code === 50014) {</div><div class=\"ql-code-block\" data-language=\"plain\">  //         MessageBox.confirm('你已被登出，可以取消继续留在该页面，或者重新登录', '确定登出', {</div><div class=\"ql-code-block\" data-language=\"plain\">  //           confirmButtonText: '重新登录',</div><div class=\"ql-code-block\" data-language=\"plain\">  //           cancelButtonText: '取消',</div><div class=\"ql-code-block\" data-language=\"plain\">  //           type: 'warning'</div><div class=\"ql-code-block\" data-language=\"plain\">  //         }).then(() =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">  //           store.dispatch('FedLogOut').then(() =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">  //             location.reload();// 为了重新实例化vue-router对象 避免bug</div><div class=\"ql-code-block\" data-language=\"plain\">  //           });</div><div class=\"ql-code-block\" data-language=\"plain\">  //         })</div><div class=\"ql-code-block\" data-language=\"plain\">  //       }</div><div class=\"ql-code-block\" data-language=\"plain\">  //       return Promise.reject('error');</div><div class=\"ql-code-block\" data-language=\"plain\">  //     } else {</div><div class=\"ql-code-block\" data-language=\"plain\">  //       return response.data;</div><div class=\"ql-code-block\" data-language=\"plain\">  //     }</div><div class=\"ql-code-block\" data-language=\"plain\">  error =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">    console.log('err' + error)// for debug</div><div class=\"ql-code-block\" data-language=\"plain\">    Message({</div><div class=\"ql-code-block\" data-language=\"plain\">      message: error.message,</div><div class=\"ql-code-block\" data-language=\"plain\">      type: 'error',</div><div class=\"ql-code-block\" data-language=\"plain\">      duration: 5 * 1000</div><div class=\"ql-code-block\" data-language=\"plain\">    })</div><div class=\"ql-code-block\" data-language=\"plain\">    return Promise.reject(error)</div><div class=\"ql-code-block\" data-language=\"plain\">  })</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">export default service</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">import request from '@/utils/request'</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">//使用</div><div class=\"ql-code-block\" data-language=\"plain\">export function getInfo(params) {</div><div class=\"ql-code-block\" data-language=\"plain\">  return request({</div><div class=\"ql-code-block\" data-language=\"plain\">    url: '/user/info',</div><div class=\"ql-code-block\" data-language=\"plain\">    method: 'get',</div><div class=\"ql-code-block\" data-language=\"plain\">    params</div><div class=\"ql-code-block\" data-language=\"plain\">  });</div><div class=\"ql-code-block\" data-language=\"plain\">}</div></div><p>比如后台项目，每一个请求都是要带 token 来验证权限的，这样封装以下的话我们就不用每个请求都手动来塞 token，或者来做一些统一的异常处理，一劳永逸。 而且因为我们的 api 是根据 <code>env</code> 环境变量动态切换的，如果以后线上出现了bug，我们只需配置一下 <code>@/config/dev.env.js</code> 再重启一下服务，就能在本地模拟线上的环境了。</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">module.exports = {</div><div class=\"ql-code-block\" data-language=\"plain\">    NODE_ENV: '\"development\"',</div><div class=\"ql-code-block\" data-language=\"plain\">    BASE_API: '\"https://api-dev\"', //修改为'\"https://api-prod\"'就行了</div><div class=\"ql-code-block\" data-language=\"plain\">    APP_ORIGIN: '\"https://wallstreetcn.com\"' //为公司打个广告 pc站为vue+ssr</div><div class=\"ql-code-block\" data-language=\"plain\">}</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div></div><p><strong>妈妈再也不用担心我调试线上bug了。</strong> 当然这里只是简单举了个例子，axios还可以执行多个并发请求，拦截器什么的，大家自行去研究吧。</p><h2>多环境</h2><p>vue-cli 默认只提供了<code>dev</code>和<code>prod</code>两种环境。但其实正真的开发流程可能还会多一个<code>sit</code>或者<code>stage</code>环境，就是所谓的测试环境和预发布环境。所以我们就要简单的修改一下代码。其实很简单就是设置不同的环境变量</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">\"build:prod\": \"NODE_ENV=production node build/build.js\",</div><div class=\"ql-code-block\" data-language=\"plain\">\"build:sit\": \"NODE_ENV=sit node build/build.js\",</div></div><p>之后在代码里自行判断，想干就干啥</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">var env = process.env.NODE_ENV === 'production' ? config.build.prodEnv : config.build.sitEnv</div></div><p>新版的 vue-cli 也内置了 <code>webpack-bundle-analyzer</code> 一个模块分析的东西，相当的好用。使用方法也很简单，和之前一样封装一个 npm script 就可以。</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">//package.json</div><div class=\"ql-code-block\" data-language=\"plain\"> \"build:sit-preview\": \"cross-env NODE_ENV=production env_config=sit npm_config_preview=true  npm_config_report=true node build/build.js\"</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">//之后通过process.env.npm_config_report来判断是否来启用webpack-bundle-analyzer</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">var BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin</div><div class=\"ql-code-block\" data-language=\"plain\">webpackConfig.plugins.push(new BundleAnalyzerPlugin())</div></div><p>效果图</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/5/3/a3a16e24b776805e548424326152e73f~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\" alt=\"analyzer.png\"></p><p>webpack-bundle-analyzer这个插件还是很有用的，对后期的代码优化什么的，最重要的是它够<strong>装逼</strong>~</p><p><br></p><h2>前后端交互</h2><p>每个公司都有自己一套的开发流程，没有绝对的好与坏。这里我来讲讲我司的前后端交互流程。</p><h3>跨域问题</h3><p>首先前后端交互不可避免的就会遇到跨域问题，我司现在全是用 <code>cors</code>来解决的，如果你司后端嫌麻烦不肯配置的话，dev环境也可以通过 <code>webpack-dev-server</code>的<code>proxy</code>来解决，开发环境用<code>nginx</code>反代理一下就好了，具体配置这里就不展开了。</p><h3>前后端的交互问题</h3><p>其实大家也知道，平时的开发中交流成本占据了我们很大一部分时间，但前后端如果有一个好的协作方式的话能解决很多时间。我司开发流程都是前后端和产品一起开会讨论项目，之后后端根据需求，首先定义数据格式和api，然后 mock api 生成好文档，我们前端才是对接接口的。这里推荐一个文档生成器 <a href=\"https://link.juejin.cn?target=http%3A%2F%2Fswagger.io%2F\" rel=\"noopener noreferrer\" target=\"_blank\">swagger</a>。 <strong>swagger</strong>是一个REST APIs文档生成工具，可以在许多不同的平台上从代码注释中自动生成，开源，支持大部分语言，社区好，总之就是一个强大，如下图的api 文档(swagger自动生成，ui忽略)</p><p><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/5/3/49a6c7a90d484892048b0b80babcf374~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\"></p><p>api 地址，需要传是没参数，需要的传参类型，返回的数据格式什么都一清二楚了。</p><p><br></p><h3>前端自行mock</h3><p>如果后端不肯来帮你 mock 数据的话，前端自己来 mock 也是很简单的。你可以使用mock server 或者使用 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbadoo%2FMockJS\" rel=\"noopener noreferrer\" target=\"_blank\">mockjs</a> + <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fthx%2FRAP\" rel=\"noopener noreferrer\" target=\"_blank\">rap</a> 也是很方便的。 不久前出的 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Feasy-mock.com%2F\" rel=\"noopener noreferrer\" target=\"_blank\">easy-mock</a>也相当的不错，还能结合 swagger。 我们大前端终于不用再看后端的脸色了~</p><h3>iconfont</h3><p>element-ui 默认的icon不是很多，这里要安利一波阿里的<a href=\"https://link.juejin.cn?target=http%3A%2F%2Ficonfont.cn%2F\" rel=\"noopener noreferrer\" target=\"_blank\">iconfont</a>简直是神器，不管是公司项目还是个人项目都在使用。它提供了png,ai,svg三种格式，同时使用也支持unicode，font-class，symbol三种方式。由于是管理后台对兼容性要求不高，楼主平时都喜欢用symbol，晒一波我司后台的图标(都是楼主自己发挥的)。</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/5/3/50761c4e9bd53f840a6dde5bb233559f~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\" alt=\"iconfont.png\"></p><p>详细具体的使用可以见文章 <a href=\"https://juejin.cn/post/6844903517564436493\" rel=\"noopener noreferrer\" target=\"_blank\">手摸手，带你优雅的使用 icon</a></p><p><br></p><h2>router-view</h2><p>different router the same component vue。真实的业务场景中，这种情况很多。比如</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/5/3/ed2de15673673276b00e205c042048e4~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\" alt=\"router-view.png\"></p><p>我创建和编辑的页面使用的是同一个component,默认情况下当这两个页面切换时并不会触发vue的created或者mounted钩子，官方说你可以通过watch $route的变化来做处理，但其实说真的还是蛮麻烦的。后来发现其实可以简单的在 router-view上加上一个唯一的key，来保证路由切换时都会重新渲染触发钩子了。这样简单的多了。</p><p><br></p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">&lt;router-view :key=\"key\"&gt;&lt;/router-view&gt;</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">computed: {</div><div class=\"ql-code-block\" data-language=\"plain\">    key() {</div><div class=\"ql-code-block\" data-language=\"plain\">        return this.$route.name !== undefined? this.$route.name + +new Date(): this.$route + +new Date()</div><div class=\"ql-code-block\" data-language=\"plain\">    }</div><div class=\"ql-code-block\" data-language=\"plain\"> }</div></div><h2>优化</h2><p>有些人会觉得现在构建是不是有点慢，我司现在技术栈是容器服务，后台项目会把dist文件夹里的东西都会打包成一个docker镜像，基本步骤为</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">npm install</div><div class=\"ql-code-block\" data-language=\"plain\">npm run build:prod</div><div class=\"ql-code-block\" data-language=\"plain\">加打包镜像，一共是耗时如下</div></div><p><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/5/3/4b23bedbc78aa03295a4a58b73d263b8~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\" alt=\"Paste_Image.png\"></p><p><br></p><p>还是属于能接受时间的范围。 主站PC站基于nodejs、Vue实现服务端渲染，所以不仅需要依赖nodejs，而且需要利用pm2进行nodejs生命周期的管理。为了加速线上镜像构建的速度，我们利用taobao源 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fregistry.npm.taobao.org\" rel=\"noopener noreferrer\" target=\"_blank\">registry.npm.taobao.org</a> 进行加速, 并且将一些常见的npm依赖打入了基础镜像，避免每次都需要重新下载。 这里注意下 建议不要使用cnpm install或者update 它的包都是一个link，反正会有各种诡异的bug，这里建议这样使用</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">npm install --registry=https://registry.npm.taobao.org</div></div><p>如果你觉得慢还是有可优化的空间如使用<code>webpack dll</code> 或者把那些第三方vendor单独打包 external出去，或者我司现在用的是http2 可以使用<code>AggressiveSplittingPlugin</code>等等，这里有需求的可以自行优化。</p><p><br></p>",
			"tags": ["Vue.js", "前端开发", "JavaScript"],
			"categories": ["编程", "技术"],
			"featuredImage": "/images/posts/vue-app.png",
			"readTime": "5分钟"
		},
		{
			"id": "2",
			"title": "带你用vue撸后台 系列二(登录权限篇)",
			"author": {
				"name": "李四",
				"profilePicture": "/images/authors/lisi.png"
			},
			"date": "2024-09-03T15:30:00Z",
			"content": "<p>进入正题，做后台项目区别于做其它的项目，权限验证与安全性是非常重要的，可以说是一个后台项目一开始就必须考虑和搭建的基础核心功能。我们所要做到的是：不同的权限对应着不同的路由，同时侧边栏也需根据不同的权限，异步生成。这里先简单说一下，我实现登录和权限验证的思路。</p><ol><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span>登录：当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个<strong>token</strong>，拿到token之后（我会将这个token存贮到cookie中，保证刷新页面后能记住用户登录状态），前端会根据token再去拉取一个 <strong>user_info</strong> 的接口来获取用户的详细信息（如用户权限，用户名等等信息）。</li><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span>权限验证：通过token获取用户对应的 <strong>role</strong>，动态根据用户的 role 算出其对应有权限的路由，通过 <strong>router.addRoutes</strong> 动态挂载这些路由。</li></ol><p>上述所有的数据和操作都是通过vuex全局管理控制的。(<strong>补充说明</strong>：刷新页面后 vuex的内容也会丢失，所以需要重复上述的那些操作)接下来，我们一起手摸手一步一步实现这个系统。</p><h2>登录篇</h2><blockquote>首先我们不管什么权限，来实现最基础的登录功能。</blockquote><p>随便找一个空白页面撸上两个input的框，一个是登录账号，一个是登录密码。再放置一个登录按钮。我们将登录按钮上绑上click事件，点击登录之后向服务端提交账号和密码进行验证。 这就是一个最简单的登录页面。如果你觉得还要写的更加完美点，你可以在向服务端提交之前对账号和密码做一次简单的校验。<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FPanJiaChen%2Fvue-element-admin%2Fblob%2Fmaster%2Fsrc%2Fviews%2Flogin%2Findex.vue\" rel=\"noopener noreferrer\" target=\"_blank\">详细代码</a></p><p><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/da4e0c8127e6dc3264a7~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\"></p><p><br></p><p><strong>click事件触发登录操作:</strong></p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">this.$store.dispatch('LoginByUsername', this.loginForm).then(() =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">  this.$router.push({ path: '/' }); //登录成功之后重定向到首页</div><div class=\"ql-code-block\" data-language=\"plain\">}).catch(err =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">  this.$message.error(err); //登录失败提示错误</div><div class=\"ql-code-block\" data-language=\"plain\">});</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div></div><p><strong>action:</strong></p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">LoginByUsername({ commit }, userInfo) {</div><div class=\"ql-code-block\" data-language=\"plain\">  const username = userInfo.username.trim()</div><div class=\"ql-code-block\" data-language=\"plain\">  return new Promise((resolve, reject) =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">    loginByUsername(username, userInfo.password).then(response =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">      const data = response.data</div><div class=\"ql-code-block\" data-language=\"plain\">      Cookies.set('Token', response.data.token) //登录成功后将token存储在cookie之中</div><div class=\"ql-code-block\" data-language=\"plain\">      commit('SET_TOKEN', data.token)</div><div class=\"ql-code-block\" data-language=\"plain\">      resolve()</div><div class=\"ql-code-block\" data-language=\"plain\">    }).catch(error =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">      reject(error)</div><div class=\"ql-code-block\" data-language=\"plain\">    });</div><div class=\"ql-code-block\" data-language=\"plain\">  });</div><div class=\"ql-code-block\" data-language=\"plain\">}</div></div><p>登录成功后，服务端会返回一个 <strong>token</strong>（该token的是一个能唯一标示用户身份的一个key），之后我们将token存储在本地cookie之中，这样下次打开页面或者刷新页面的时候能记住用户的登录状态，不用再去登录页面重新登录了。</p><p>ps:为了保证安全性，我司现在后台所有token有效期(Expires/Max-Age)都是Session，就是当浏览器关闭了就丢失了。重新打开游览器都需要重新登录验证，后端也会在每周固定一个时间点重新刷新token，让后台用户全部重新登录一次，确保后台用户不会因为电脑遗失或者其它原因被人随意使用账号。</p><h3>获取用户信息</h3><p>用户登录成功之后，我们会在全局钩子<code>router.beforeEach</code>中拦截路由，判断是否已获得token，在获得token之后我们就要去获取用户的基本信息了</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">//router.beforeEach</div><div class=\"ql-code-block\" data-language=\"plain\">if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息</div><div class=\"ql-code-block\" data-language=\"plain\">  store.dispatch('GetInfo').then(res =&gt; { // 拉取user_info</div><div class=\"ql-code-block\" data-language=\"plain\">    const roles = res.data.role;</div><div class=\"ql-code-block\" data-language=\"plain\">    next();//resolve 钩子</div><div class=\"ql-code-block\" data-language=\"plain\">  })</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div></div><p>就如前面所说的，我只在本地存储了一个用户的token，并没有存储别的用户信息（如用户权限，用户名，用户头像等）。有些人会问为什么不把一些其它的用户信息也存一下？主要出于如下的考虑：</p><p>假设我把用户权限和用户名也存在了本地，但我这时候用另一台电脑登录修改了自己的用户名，之后再用这台存有之前用户信息的电脑登录，它默认会去读取本地 cookie 中的名字，并不会去拉去新的用户信息。</p><p>所以现在的策略是：页面会先从 cookie 中查看是否存有 token，没有，就走一遍上一部分的流程重新登录，如果有token,就会把这个 token 返给后端去拉取user_info，保证用户信息是最新的。 当然如果是做了单点登录得功能的话，用户信息存储在本地也是可以的。当你一台电脑登录时，另一台会被提下线，所以总会重新登录获取最新的内容。</p><p>而且从代码层面我建议还是把 <code>login</code>和<code>get_user_info</code>两件事分开比较好，在这个后端全面微服务的年代，后端同学也想写优雅的代码~</p><h2>权限篇</h2><p>先说一说我权限控制的主体思路，前端会有一份路由表，它表示了每一个路由可访问的权限。当用户登录之后，通过 <strong>token</strong> 获取用户的 <strong>role</strong> ，动态根据用户的 <strong>role</strong> 算出其对应有权限的路由，再通过<code>router.addRoutes</code>动态挂载路由。但这些控制都只是页面级的，说白了前端再怎么做权限控制都不是绝对安全的，后端的权限验证是逃不掉的。</p><p>我司现在就是前端来控制页面级的权限，不同权限的用户显示不同的侧边栏和限制其所能进入的页面(也做了少许按钮级别的权限控制)，后端则会验证每一个涉及请求的操作，验证其是否有该操作的权限，每一个后台的请求不管是 get 还是 post 都会让前端在请求 <code>header</code>里面携带用户的 <strong>token</strong>，后端会根据该 <strong>token</strong> 来验证用户是否有权限执行该操作。若没有权限则抛出一个对应的状态码，前端检测到该状态码，做出相对应的操作。</p><h3>权限 前端or后端 来控制？</h3><p>有很多人表示他们公司的路由表是于后端根据用户的权限动态生成的，我司不采取这种方式的原因如下：</p><ol><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span>项目不断的迭代你会异常痛苦，前端新开发一个页面还要让后端配一下路由和权限，让我们想了曾经<strong>前后端不分离</strong>，被后端支配的那段恐怖时间了。</li><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span>其次，就拿我司的业务来说，虽然后端的确也是有权限验证的，但它的验证其实是针对业务来划分的，比如超级编辑可以发布文章，而实习编辑只能编辑文章不能发布，但对于前端来说不管是超级编辑还是实习编辑都是有权限进入文章编辑页面的。所以前端和后端权限的划分是不太一致。</li><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span>还有一点是就vue2.2.0之前异步挂载路由是很麻烦的一件事！不过好在官方也出了新的api，虽然本意是来解决ssr的痛点的。。。</li></ol><h3>addRoutes</h3><p>在之前通过后端动态返回前端路由一直很难做的，因为vue-router必须是要vue在实例化之前就挂载上去的，不太方便动态改变。<strong>不过好在vue2.2.0以后新增了router.addRoutes</strong></p><blockquote>Dynamically add more routes to the router. The argument must be an Array using the same route config format with the routes constructor option.</blockquote><p>有了这个我们就可相对方便的做权限控制了。(楼主之前在权限控制也走了不少歪路，可以在项目的commit记录中看到，重构了很多次，最早没用addRoute整个权限控制代码里都是各种if/else的逻辑判断，代码相当的耦合和复杂)</p><h2>具体实现</h2><ol><li data-list=\"ordered\"><span class=\"ql-ui\" contenteditable=\"false\"></span>创建vue实例的时候将vue-router挂载，但这个时候vue-router挂载一些登录或者不用权限的公用的页面。</li><li data-list=\"ordered\"><span class=\"ql-ui\" contenteditable=\"false\"></span>当用户登录后，获取用role，将role和路由表每个页面的需要的权限作比较，生成最终用户可访问的路由表。</li><li data-list=\"ordered\"><span class=\"ql-ui\" contenteditable=\"false\"></span>调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。</li><li data-list=\"ordered\"><span class=\"ql-ui\" contenteditable=\"false\"></span>使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。</li></ol><h3>router.js</h3><p>首先我们实现router.js路由表，这里就拿前端控制路由来举例(后端存储的也差不多，稍微改造一下就好了)</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">// router.js</div><div class=\"ql-code-block\" data-language=\"plain\">import Vue from 'vue';</div><div class=\"ql-code-block\" data-language=\"plain\">import Router from 'vue-router';</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">import Login from '../views/login/';</div><div class=\"ql-code-block\" data-language=\"plain\">const dashboard = resolve =&gt; require(['../views/dashboard/index'], resolve);</div><div class=\"ql-code-block\" data-language=\"plain\">//使用了vue-routerd的[Lazy Loading Routes</div><div class=\"ql-code-block\" data-language=\"plain\">](https://router.vuejs.org/en/advanced/lazy-loading.html)</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">//所有权限通用路由表 </div><div class=\"ql-code-block\" data-language=\"plain\">//如首页和登录页和一些不用权限的公用页面</div><div class=\"ql-code-block\" data-language=\"plain\">export const constantRouterMap = [</div><div class=\"ql-code-block\" data-language=\"plain\">  { path: '/login', component: Login },</div><div class=\"ql-code-block\" data-language=\"plain\">  {</div><div class=\"ql-code-block\" data-language=\"plain\">    path: '/',</div><div class=\"ql-code-block\" data-language=\"plain\">    component: Layout,</div><div class=\"ql-code-block\" data-language=\"plain\">    redirect: '/dashboard',</div><div class=\"ql-code-block\" data-language=\"plain\">    name: '首页',</div><div class=\"ql-code-block\" data-language=\"plain\">    children: [{ path: 'dashboard', component: dashboard }]</div><div class=\"ql-code-block\" data-language=\"plain\">  },</div><div class=\"ql-code-block\" data-language=\"plain\">]</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">//实例化vue的时候只挂载constantRouter</div><div class=\"ql-code-block\" data-language=\"plain\">export default new Router({</div><div class=\"ql-code-block\" data-language=\"plain\">  routes: constantRouterMap</div><div class=\"ql-code-block\" data-language=\"plain\">});</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">//异步挂载的路由</div><div class=\"ql-code-block\" data-language=\"plain\">//动态需要根据权限加载的路由表 </div><div class=\"ql-code-block\" data-language=\"plain\">export const asyncRouterMap = [</div><div class=\"ql-code-block\" data-language=\"plain\">  {</div><div class=\"ql-code-block\" data-language=\"plain\">    path: '/permission',</div><div class=\"ql-code-block\" data-language=\"plain\">    component: Layout,</div><div class=\"ql-code-block\" data-language=\"plain\">    name: '权限测试',</div><div class=\"ql-code-block\" data-language=\"plain\">    meta: { role: ['admin','super_editor'] }, //页面需要的权限</div><div class=\"ql-code-block\" data-language=\"plain\">    children: [</div><div class=\"ql-code-block\" data-language=\"plain\">    { </div><div class=\"ql-code-block\" data-language=\"plain\">      path: 'index',</div><div class=\"ql-code-block\" data-language=\"plain\">      component: Permission,</div><div class=\"ql-code-block\" data-language=\"plain\">      name: '权限测试页',</div><div class=\"ql-code-block\" data-language=\"plain\">      meta: { role: ['admin','super_editor'] }  //页面需要的权限</div><div class=\"ql-code-block\" data-language=\"plain\">    }]</div><div class=\"ql-code-block\" data-language=\"plain\">  },</div><div class=\"ql-code-block\" data-language=\"plain\">  { path: '*', redirect: '/404', hidden: true }</div><div class=\"ql-code-block\" data-language=\"plain\">];</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div></div><p>这里我们根据 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Frouter.vuejs.org%2Fen%2Fadvanced%2Fmeta.html\" rel=\"noopener noreferrer\" target=\"_blank\">vue-router官方推荐</a> 的方法通过meta标签来标示改页面能访问的权限有哪些。如<code>meta: { role: ['admin','super_editor'] }</code>表示该页面只有admin和超级编辑才能有资格进入。</p><p><strong>注意事项</strong>：这里有一个需要非常注意的地方就是 <code>404</code> 页面一定要最后加载，如果放在<code>constantRouterMap</code>一同声明了<code>404</code>，后面的所以页面都会被拦截到<code>404</code>，详细的问题见<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue-router%2Fissues%2F1176\" rel=\"noopener noreferrer\" target=\"_blank\">addRoutes when you've got a wildcard route for 404s does not work</a></p><h3>main.js</h3><p><strong>关键的main.js</strong></p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">// main.js</div><div class=\"ql-code-block\" data-language=\"plain\">router.beforeEach((to, from, next) =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">  if (store.getters.token) { // 判断是否有token</div><div class=\"ql-code-block\" data-language=\"plain\">    if (to.path === '/login') {</div><div class=\"ql-code-block\" data-language=\"plain\">      next({ path: '/' });</div><div class=\"ql-code-block\" data-language=\"plain\">    } else {</div><div class=\"ql-code-block\" data-language=\"plain\">      if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息</div><div class=\"ql-code-block\" data-language=\"plain\">        store.dispatch('GetInfo').then(res =&gt; { // 拉取info</div><div class=\"ql-code-block\" data-language=\"plain\">          const roles = res.data.role;</div><div class=\"ql-code-block\" data-language=\"plain\">          store.dispatch('GenerateRoutes', { roles }).then(() =&gt; { // 生成可访问的路由表</div><div class=\"ql-code-block\" data-language=\"plain\">            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表</div><div class=\"ql-code-block\" data-language=\"plain\">            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record</div><div class=\"ql-code-block\" data-language=\"plain\">          })</div><div class=\"ql-code-block\" data-language=\"plain\">        }).catch(err =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">          console.log(err);</div><div class=\"ql-code-block\" data-language=\"plain\">        });</div><div class=\"ql-code-block\" data-language=\"plain\">      } else {</div><div class=\"ql-code-block\" data-language=\"plain\">        next() //当有用户权限的时候，说明所有可访问路由已生成 如访问没权限的全面会自动进入404页面</div><div class=\"ql-code-block\" data-language=\"plain\">      }</div><div class=\"ql-code-block\" data-language=\"plain\">    }</div><div class=\"ql-code-block\" data-language=\"plain\">  } else {</div><div class=\"ql-code-block\" data-language=\"plain\">    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入</div><div class=\"ql-code-block\" data-language=\"plain\">      next();</div><div class=\"ql-code-block\" data-language=\"plain\">    } else {</div><div class=\"ql-code-block\" data-language=\"plain\">      next('/login'); // 否则全部重定向到登录页</div><div class=\"ql-code-block\" data-language=\"plain\">    }</div><div class=\"ql-code-block\" data-language=\"plain\">  }</div><div class=\"ql-code-block\" data-language=\"plain\">});</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div></div><p>这里的router.beforeEach也结合了上一章讲的一些登录逻辑代码。</p><p><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/5f3559ebd7c841ffaa17.png~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\" alt=\"重构之前权限判断代码\"></p><p>上面一张图就是在使用<code>addRoutes</code>方法之前的权限判断，非常的繁琐，因为我是把所有的路由都挂在了上去，所有我要各种判断当前的用户是否有权限进入该页面，各种<code>if/else</code>的嵌套，维护起来相当的困难。但现在有了<code>addRoutes</code>之后就非常的方便，我只挂载了用户有权限进入的页面，没权限，路由自动帮我跳转的<code>404</code>,省去了不少的判断。</p><p><br></p><p>这里还有一个小hack的地方，就是<code>router.addRoutes</code>之后的<code>next()</code>可能会失效，因为可能<code>next()</code>的时候路由并没有完全add完成，好在查阅文档发现</p><blockquote>next('/') or next({ path: '/' }): redirect to a different location. The current navigation will be aborted and a new one will be started.</blockquote><p>这样我们就可以简单的通过<code>next(to)</code>巧妙的避开之前的那个问题了。这行代码重新进入<code>router.beforeEach</code>这个钩子，这时候再通过<code>next()</code>来释放钩子，就能确保所有的路由都已经挂在完成了。</p><h3>store/permission.js</h3><p>就来就讲一讲 <code>GenerateRoutes Action</code></p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">// store/permission.js</div><div class=\"ql-code-block\" data-language=\"plain\">import { asyncRouterMap, constantRouterMap } from 'src/router';</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">function hasPermission(roles, route) {</div><div class=\"ql-code-block\" data-language=\"plain\">  if (route.meta &amp;&amp; route.meta.role) {</div><div class=\"ql-code-block\" data-language=\"plain\">    return roles.some(role =&gt; route.meta.role.indexOf(role) &gt;= 0)</div><div class=\"ql-code-block\" data-language=\"plain\">  } else {</div><div class=\"ql-code-block\" data-language=\"plain\">    return true</div><div class=\"ql-code-block\" data-language=\"plain\">  }</div><div class=\"ql-code-block\" data-language=\"plain\">}</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">const permission = {</div><div class=\"ql-code-block\" data-language=\"plain\">  state: {</div><div class=\"ql-code-block\" data-language=\"plain\">    routers: constantRouterMap,</div><div class=\"ql-code-block\" data-language=\"plain\">    addRouters: []</div><div class=\"ql-code-block\" data-language=\"plain\">  },</div><div class=\"ql-code-block\" data-language=\"plain\">  mutations: {</div><div class=\"ql-code-block\" data-language=\"plain\">    SET_ROUTERS: (state, routers) =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">      state.addRouters = routers;</div><div class=\"ql-code-block\" data-language=\"plain\">      state.routers = constantRouterMap.concat(routers);</div><div class=\"ql-code-block\" data-language=\"plain\">    }</div><div class=\"ql-code-block\" data-language=\"plain\">  },</div><div class=\"ql-code-block\" data-language=\"plain\">  actions: {</div><div class=\"ql-code-block\" data-language=\"plain\">    GenerateRoutes({ commit }, data) {</div><div class=\"ql-code-block\" data-language=\"plain\">      return new Promise(resolve =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">        const { roles } = data;</div><div class=\"ql-code-block\" data-language=\"plain\">        const accessedRouters = asyncRouterMap.filter(v =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">          if (roles.indexOf('admin') &gt;= 0) return true;</div><div class=\"ql-code-block\" data-language=\"plain\">          if (hasPermission(roles, v)) {</div><div class=\"ql-code-block\" data-language=\"plain\">            if (v.children &amp;&amp; v.children.length &gt; 0) {</div><div class=\"ql-code-block\" data-language=\"plain\">              v.children = v.children.filter(child =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">                if (hasPermission(roles, child)) {</div><div class=\"ql-code-block\" data-language=\"plain\">                  return child</div><div class=\"ql-code-block\" data-language=\"plain\">                }</div><div class=\"ql-code-block\" data-language=\"plain\">                return false;</div><div class=\"ql-code-block\" data-language=\"plain\">              });</div><div class=\"ql-code-block\" data-language=\"plain\">              return v</div><div class=\"ql-code-block\" data-language=\"plain\">            } else {</div><div class=\"ql-code-block\" data-language=\"plain\">              return v</div><div class=\"ql-code-block\" data-language=\"plain\">            }</div><div class=\"ql-code-block\" data-language=\"plain\">          }</div><div class=\"ql-code-block\" data-language=\"plain\">          return false;</div><div class=\"ql-code-block\" data-language=\"plain\">        });</div><div class=\"ql-code-block\" data-language=\"plain\">        commit('SET_ROUTERS', accessedRouters);</div><div class=\"ql-code-block\" data-language=\"plain\">        resolve();</div><div class=\"ql-code-block\" data-language=\"plain\">      })</div><div class=\"ql-code-block\" data-language=\"plain\">    }</div><div class=\"ql-code-block\" data-language=\"plain\">  }</div><div class=\"ql-code-block\" data-language=\"plain\">};</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">export default permission;</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div></div><p>这里的代码说白了就是干了一件事，通过用户的权限和之前在router.js里面asyncRouterMap的每一个页面所需要的权限做匹配，最后返回一个该用户能够访问路由有哪些。</p><h3>侧边栏</h3><p>最后一个涉及到权限的地方就是侧边栏，不过在前面的基础上已经很方便就能实现动态显示侧边栏了。这里侧边栏基于element-ui的NavMenu来实现的。 代码有点多不贴详细的代码了，有兴趣的可以直接去github上看<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FPanJiaChen%2Fvue-element-admin%2Ftree%2Fmaster%2Fsrc%2Fviews%2Flayout%2Fcomponents%2FSidebar\" rel=\"noopener noreferrer\" target=\"_blank\">地址</a>，或者直接看关于侧边栏的<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fpanjiachen.github.io%2Fvue-element-admin-site%2F%23%2Frouter-and-nav\" rel=\"noopener noreferrer\" target=\"_blank\">文档</a>。</p><p>说白了就是遍历之前算出来的<code>permission_routers</code>，通过vuex拿到之后动态v-for渲染而已。不过这里因为有一些业务需求所以加了很多判断 比如我们在定义路由的时候会加很多参数</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">/**</div><div class=\"ql-code-block\" data-language=\"plain\">* hidden: true                   if `hidden:true` will not show in the sidebar(default is false)</div><div class=\"ql-code-block\" data-language=\"plain\">* redirect: noredirect           if `redirect:noredirect` will no redirct in the breadcrumb</div><div class=\"ql-code-block\" data-language=\"plain\">* name:'router-name'             the name is used by &lt;keep-alive&gt; (must set!!!)</div><div class=\"ql-code-block\" data-language=\"plain\">* meta : {</div><div class=\"ql-code-block\" data-language=\"plain\">   role: ['admin','editor']     will control the page role (you can set multiple roles)</div><div class=\"ql-code-block\" data-language=\"plain\">   title: 'title'               the name show in submenu and breadcrumb (recommend set)</div><div class=\"ql-code-block\" data-language=\"plain\">   icon: 'svg-name'             the icon show in the sidebar,</div><div class=\"ql-code-block\" data-language=\"plain\">   noCache: true                if fasle ,the page will no be cached(default is false)</div><div class=\"ql-code-block\" data-language=\"plain\"> }</div><div class=\"ql-code-block\" data-language=\"plain\">**/</div></div><p>这里仅供参考，而且本项目为了支持无限嵌套路由，所有侧边栏这块使用了递归组件。如需要请大家自行改造，来打造满足自己业务需求的侧边栏。</p><p><strong>侧边栏高亮问题</strong>:很多人在群里问为什么自己的侧边栏不能跟着自己的路由高亮，其实很简单，element-ui官方已经给了<code>default-active</code>所以我们只要</p><blockquote>:default-active=\"$route.path\" 将<code>default-active</code>一直指向当前路由就可以了，就是这么简单</blockquote><h2>按钮级别权限控制</h2><p>有很多人一直在问关于按钮级别粒度的权限控制怎么做。我司现在是这样的，真正需要按钮级别控制的地方不是很多，现在是通过获取到用户的role之后，在前端用v-if手动判断来区分不同权限对应的按钮的。理由前面也说了，我司颗粒度的权限判断是交给后端来做的，每个操作后端都会进行权限判断。而且我觉得其实前端真正需要按钮级别判断的地方不是很多，如果一个页面有很多种不同权限的按钮，我觉得更多的应该是考虑产品层面是否设计合理。当然你强行说我想做按钮级别的权限控制，你也可以参照路由层面的做法，搞一个操作权限表。。。但个人觉得有点多此一举。或者将它封装成一个指令都是可以的。</p><h2>axios拦截器</h2><p>这里再说一说 axios 吧。虽然在上一篇<a href=\"https://juejin.cn/post/6844903476661583880\" rel=\"noopener noreferrer\" target=\"_blank\">系列文章</a>中简单介绍过，不过这里还是要在唠叨一下。如上文所说，我司服务端对每一个请求都会验证权限，所以这里我们针对业务封装了一下请求。首先我们通过<strong>request拦截器</strong>在每个请求头里面塞入<strong>token</strong>，好让后端对请求进行权限验证。并创建一个respone拦截器，当服务端返回特殊的状态码，我们统一做处理，如没权限或者token失效等操作。</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">import axios from 'axios'</div><div class=\"ql-code-block\" data-language=\"plain\">import { Message } from 'element-ui'</div><div class=\"ql-code-block\" data-language=\"plain\">import store from '@/store'</div><div class=\"ql-code-block\" data-language=\"plain\">import { getToken } from '@/utils/auth'</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">// 创建axios实例</div><div class=\"ql-code-block\" data-language=\"plain\">const service = axios.create({</div><div class=\"ql-code-block\" data-language=\"plain\">  baseURL: process.env.BASE_API, // api的base_url</div><div class=\"ql-code-block\" data-language=\"plain\">  timeout: 5000 // 请求超时时间</div><div class=\"ql-code-block\" data-language=\"plain\">})</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">// request拦截器</div><div class=\"ql-code-block\" data-language=\"plain\">service.interceptors.request.use(config =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">  // Do something before request is sent</div><div class=\"ql-code-block\" data-language=\"plain\">  if (store.getters.token) {</div><div class=\"ql-code-block\" data-language=\"plain\">    config.headers['X-Token'] = getToken() // 让每个请求携带token--['X-Token']为自定义key 请根据实际情况自行修改</div><div class=\"ql-code-block\" data-language=\"plain\">  }</div><div class=\"ql-code-block\" data-language=\"plain\">  return config</div><div class=\"ql-code-block\" data-language=\"plain\">}, error =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">  // Do something with request error</div><div class=\"ql-code-block\" data-language=\"plain\">  console.log(error) // for debug</div><div class=\"ql-code-block\" data-language=\"plain\">  Promise.reject(error)</div><div class=\"ql-code-block\" data-language=\"plain\">})</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">// respone拦截器</div><div class=\"ql-code-block\" data-language=\"plain\">service.interceptors.response.use(</div><div class=\"ql-code-block\" data-language=\"plain\">  response =&gt; response,</div><div class=\"ql-code-block\" data-language=\"plain\">  /**</div><div class=\"ql-code-block\" data-language=\"plain\">  * 下面的注释为通过response自定义code来标示请求状态，当code返回如下情况为权限有问题，登出并返回到登录页</div><div class=\"ql-code-block\" data-language=\"plain\">  * 如通过xmlhttprequest 状态码标识 逻辑可写在下面error中</div><div class=\"ql-code-block\" data-language=\"plain\">  */</div><div class=\"ql-code-block\" data-language=\"plain\">  //  const res = response.data;</div><div class=\"ql-code-block\" data-language=\"plain\">  //     if (res.code !== 20000) {</div><div class=\"ql-code-block\" data-language=\"plain\">  //       Message({</div><div class=\"ql-code-block\" data-language=\"plain\">  //         message: res.message,</div><div class=\"ql-code-block\" data-language=\"plain\">  //         type: 'error',</div><div class=\"ql-code-block\" data-language=\"plain\">  //         duration: 5 * 1000</div><div class=\"ql-code-block\" data-language=\"plain\">  //       });</div><div class=\"ql-code-block\" data-language=\"plain\">  //       // 50008:非法的token; 50012:其他客户端登录了;  50014:Token 过期了;</div><div class=\"ql-code-block\" data-language=\"plain\">  //       if (res.code === 50008 || res.code === 50012 || res.code === 50014) {</div><div class=\"ql-code-block\" data-language=\"plain\">  //         MessageBox.confirm('你已被登出，可以取消继续留在该页面，或者重新登录', '确定登出', {</div><div class=\"ql-code-block\" data-language=\"plain\">  //           confirmButtonText: '重新登录',</div><div class=\"ql-code-block\" data-language=\"plain\">  //           cancelButtonText: '取消',</div><div class=\"ql-code-block\" data-language=\"plain\">  //           type: 'warning'</div><div class=\"ql-code-block\" data-language=\"plain\">  //         }).then(() =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">  //           store.dispatch('FedLogOut').then(() =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">  //             location.reload();// 为了重新实例化vue-router对象 避免bug</div><div class=\"ql-code-block\" data-language=\"plain\">  //           });</div><div class=\"ql-code-block\" data-language=\"plain\">  //         })</div><div class=\"ql-code-block\" data-language=\"plain\">  //       }</div><div class=\"ql-code-block\" data-language=\"plain\">  //       return Promise.reject('error');</div><div class=\"ql-code-block\" data-language=\"plain\">  //     } else {</div><div class=\"ql-code-block\" data-language=\"plain\">  //       return response.data;</div><div class=\"ql-code-block\" data-language=\"plain\">  //     }</div><div class=\"ql-code-block\" data-language=\"plain\">  error =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">    console.log('err' + error)// for debug</div><div class=\"ql-code-block\" data-language=\"plain\">    Message({</div><div class=\"ql-code-block\" data-language=\"plain\">      message: error.message,</div><div class=\"ql-code-block\" data-language=\"plain\">      type: 'error',</div><div class=\"ql-code-block\" data-language=\"plain\">      duration: 5 * 1000</div><div class=\"ql-code-block\" data-language=\"plain\">    })</div><div class=\"ql-code-block\" data-language=\"plain\">    return Promise.reject(error)</div><div class=\"ql-code-block\" data-language=\"plain\">  })</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">export default service</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div></div><h3>两步验证</h3><p><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/eae2458b99c83066ce61.gif~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\"></p><p><br></p><p>文章一开始也说了，后台的安全性是很重要的，简简单单的一个账号+密码的方式是很难保证安全性的。所以我司的后台项目都是用了两步验证的方式，之前我们也尝试过使用基于 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Fgoogle-authenticator\" rel=\"noopener noreferrer\" target=\"_blank\">google-authenticator</a> 或者<code>youbikey</code>这样的方式但难度和操作成本都比较大。后来还是准备借助腾讯爸爸，这年代谁不用微信。。。安全性腾讯爸爸也帮我做好了保障。 <strong>楼主建议</strong>两步验证要支持多个渠道不要只微信或者QQ，前段时间QQ第三方登录就出了bug，官方两三天才修好的，害我背了锅/(ㄒoㄒ)/~~ 。</p><p>这里的两部验证有点名不副实，其实就是账号密码验证过之后还需要一个绑定的第三方平台登录验证而已。 写起来也很简单，在原有登录得逻辑上改造一下就好。</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">this.$store.dispatch('LoginByEmail', this.loginForm).then(() =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">  //this.$router.push({ path: '/' });</div><div class=\"ql-code-block\" data-language=\"plain\">  //不重定向到首页</div><div class=\"ql-code-block\" data-language=\"plain\">  this.showDialog = true //弹出选择第三方平台的dialog</div><div class=\"ql-code-block\" data-language=\"plain\">}).catch(err =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">  this.$message.error(err); //登录失败提示错误</div><div class=\"ql-code-block\" data-language=\"plain\">});</div></div><p>登录成功之后不直接跳到首页而是让用户两步登录，选择登录得平台。 接下来就是所有第三方登录一样的地方通过 OAuth2.0 授权。这个各大平台大同小异，大家自行查阅文档，不展开了，就说一个微信授权比较坑的地方。<strong>注意</strong>你连参数的顺序都不能换，不然会验证不通过。<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FPanJiaChen%2Fvue-element-admin%2Fblob%2Fmaster%2Fsrc%2Fviews%2Flogin%2Fsocialsignin.vue\" rel=\"noopener noreferrer\" target=\"_blank\">具体代码</a>，同时我也封装了<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FPanJiaChen%2Fvue-element-admin%2Fblob%2Fmaster%2Fsrc%2Futils%2FopenWindow.js\" rel=\"noopener noreferrer\" target=\"_blank\">openWindow</a>方法大家自行看吧。 当第三方授权成功之后都会跳到一个你之前有一个传入redirect——uri的页面</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/6a155caa0fba81f0d188~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\"></p><p>如微信还必须是你授权账号的一级域名。所以你授权的域名是vue-element-admin.com,你就必须重定向到vue-element-admin.com/xxx/下面，所以你需要写一个重定向的服务，如vue-element-admin.com/auth/redirect?a.com 跳到该页面时会再次重定向给a.com。</p><p><br></p><p>所以我们后台也需要开一个authredirect页面：<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FPanJiaChen%2Fvue-element-admin%2Fblob%2Fmaster%2Fsrc%2Fviews%2Flogin%2Fauthredirect.vue\" rel=\"noopener noreferrer\" target=\"_blank\">代码</a>。他的作用是第三方登录成功之后会默认跳到授权的页面，授权的页面会再次重定向回我们的后台，由于是spa，改变路由的体验不好，我们通过<code>window.opener.location.href</code>的方式改变hash，在login.js里面再监听hash的变化。当hash变化时，获取之前第三方登录成功返回的code与第一步账号密码登录之后返回的uid一同发送给服务端验证是否正确，如果正确，这时候就是真正的登录成功。</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\"> created() {</div><div class=\"ql-code-block\" data-language=\"plain\">     window.addEventListener('hashchange', this.afterQRScan);</div><div class=\"ql-code-block\" data-language=\"plain\">   },</div><div class=\"ql-code-block\" data-language=\"plain\">   destroyed() {</div><div class=\"ql-code-block\" data-language=\"plain\">     window.removeEventListener('hashchange', this.afterQRScan);</div><div class=\"ql-code-block\" data-language=\"plain\">   },</div><div class=\"ql-code-block\" data-language=\"plain\">   afterQRScan() {</div><div class=\"ql-code-block\" data-language=\"plain\">     const hash = window.location.hash.slice(1);</div><div class=\"ql-code-block\" data-language=\"plain\">     const hashObj = getQueryObject(hash);</div><div class=\"ql-code-block\" data-language=\"plain\">     const originUrl = window.location.origin;</div><div class=\"ql-code-block\" data-language=\"plain\">     history.replaceState({}, '', originUrl);</div><div class=\"ql-code-block\" data-language=\"plain\">     const codeMap = {</div><div class=\"ql-code-block\" data-language=\"plain\">       wechat: 'code',</div><div class=\"ql-code-block\" data-language=\"plain\">       tencent: 'code'</div><div class=\"ql-code-block\" data-language=\"plain\">     };</div><div class=\"ql-code-block\" data-language=\"plain\">     const codeName = hashObj[codeMap[this.auth_type]];</div><div class=\"ql-code-block\" data-language=\"plain\">     this.$store.dispatch('LoginByThirdparty', codeName).then(() =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">       this.$router.push({</div><div class=\"ql-code-block\" data-language=\"plain\">         path: '/'</div><div class=\"ql-code-block\" data-language=\"plain\">       });</div><div class=\"ql-code-block\" data-language=\"plain\">     });</div><div class=\"ql-code-block\" data-language=\"plain\">   }</div></div><p>到这里涉及登录权限的东西也差不多讲完了，这里楼主只是给了大家一个实现的思路(都是楼主不断摸索的血泪史)，每个公司实现的方案都有些出入，请谨慎选择适合自己业务形态的解决方案。",
			"tags": ["JavaScript", "异步编程", "Promise"],
			"categories": ["编程", "技术"],
			"featuredImage": "/images/posts/async-programming.png",
			"readTime": "7分钟"
		},
		{
			"id": "2",
			"title": "带你用vue撸后台 系列三(实战篇)",
			"author": {
				"name": "李四",
				"profilePicture": "/images/authors/lisi.png"
			},
			"date": "2024-09-03T15:30:00Z",
			"content": "<h2>前言</h2><p>在前面两篇文章中已经把基础工作环境构建完成，也已经把后台核心的登录和权限问题完成了，现在手摸手，一起进入实操。</p><h2>Element</h2><p>去年十月份开始用 vue 做管理后台的时候毫不犹豫的就选择了 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FElemeFE%2Felement\" rel=\"noopener noreferrer\" target=\"_blank\">element-ui</a>，那时候 vue2.0 刚发布也没多久，市面上也没有很多其它的 vue2.0 的 ui 框架可供选择。虽然 <code>element-ui</code> 也有很多的不足，前期的bug也不少，但我还是选择了它，简单说一下我选择<code>element-ui</code>的原因吧：</p><ol><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span>有大厂背书 : 虽然核心开发只有两三个人，但至少不用担心哪天就不维护，带着小姨子跑路了</li><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span>持续迭代 : <code>element-ui</code>发版至今release了四十多个版本，之前平均都是一周一个小版本更新(是不是不小心暴露了它bug多的问题/(ㄒoㄒ)/~~)(ps: 至2017.12.4 已经迭代了74个版本，还保持着较高更新频率)。</li><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span>生态圈优异，社区活跃 ：其 contributors已经有250多人(前期我有饶有兴致的贡献过几个pr，参与过七八十个issue)，社区里也有很多基于<code>element-ui</code> 的拓展组件，也有很多相关的 qq 讨论群或者 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgitter.im%2FElemeFE%2Felement\" rel=\"noopener noreferrer\" target=\"_blank\">gitter</a>。</li><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span>社区的认可:目前Element已经是vue相关最多star的开源项目了，体现出了社区对其的认可。</li></ol><p>说了这么多优点，作为一个资深<code>element-ui</code>用户还是有些要抱怨的~和react老大哥 <strong><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fant.design%2F\" rel=\"noopener noreferrer\" target=\"_blank\">Ant Design</a></strong> 相比还是有一定的差距的，不管是组件的丰富性，参数的可配性还是文档的完整性，亦或是UI的交互和美观度。不过 ant 也是经过了近9k次commit的不断打磨，才有了今天。我也相信 <code>element-ui</code>也会越来越好的。</p><p>这里还有一些其它的框架(只讨论pc端的框架)大家可以自行选择：</p><ol><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span><strong><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fiview%2Fiview\" rel=\"noopener noreferrer\" target=\"_blank\">ivew</a></strong> 一国人个人写的框架，美观度和交互性都不错，有种介于Element和Ant之间的感觉，之前和element团队小小的撕了一下，有兴趣的自己去<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F57118065\" rel=\"noopener noreferrer\" target=\"_blank\">围观</a>吧，框架还是很不做的，一个人能做出这样，也是很不容易的。<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F25893972\" rel=\"noopener noreferrer\" target=\"_blank\">作者公开信件</a></li><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span><strong><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvue-bulma%2Fvue-admin\" rel=\"noopener noreferrer\" target=\"_blank\">vue-admin</a></strong> 也是一个不错的选择，代码写的和不错，官方也出了一个admin的架子，也很值得借鉴</li><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span><strong><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuematerial%2Fvue-material\" rel=\"noopener noreferrer\" target=\"_blank\">vue-material</a></strong> 一个material design vue框架库</li><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span><strong><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuetifyjs%2Fvuetify\" rel=\"noopener noreferrer\" target=\"_blank\">vuetify</a></strong> 又是一个material design vue框架库</li><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span><strong><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FJosephusPaye%2FKeen-UI\" rel=\"noopener noreferrer\" target=\"_blank\">Keen-UI</a></strong> 又又是一个material design vue框架库</li><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span><strong><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmrholek%2FCoreUI-Free-Bootstrap-Admin-Template\" rel=\"noopener noreferrer\" target=\"_blank\">CoreUI-Free-Bootstrap-Admin-Template</a></strong> 和以前的Bootstrap一样，搭好了一个完整的架子，大家可以进行二次拓展，它有vue,react,angular多个版本</li><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span><strong><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fframework7io%2FFramework7-Vue\" rel=\"noopener noreferrer\" target=\"_blank\">Framework7-Vue</a></strong> 个人感觉这是本人体验到现在移动端体验最好的框架。不过<code>Framework7-Vue</code>感觉还不是很完善，还需要观望一段时间。而且它有自己的路由规则，所以不能使用 <code>vue-router</code>，这点还是很不方便的。</li></ol><p>简单列举了一些主流的框架，不得不感慨现在vue的生态圈真是太繁荣了，上述框架楼主并没有深入使用过，不好发表太多建议，大家自行甄别适合自己业务的框架吧。</p><p><strong>这里开始我们会开始介绍一些结合Element的开发经验。</strong></p><h2>基于Element的动态换肤</h2><p>有些产品就是这么残忍，能完成需求就不错了，还要让我们做动态换肤。Element官网上也提供了自定义主题的<a href=\"https://link.juejin.cn?target=http%3A%2F%2Felement.eleme.io%2F%23%2Fzh-CN%2Fcomponent%2Fcustom-theme\" rel=\"noopener noreferrer\" target=\"_blank\">方案</a> 同时也提供了一个在线自定义主题的<a href=\"https://link.juejin.cn?target=https%3A%2F%2Felementui.github.io%2Ftheme-preview%2F%23%2Fzh-CN\" rel=\"noopener noreferrer\" target=\"_blank\">demo</a></p><p><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/b800391d5fd8b359618e.gif~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\"></p><p><br></p><p>是不是很酷，作者也说明了实现的方案 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FElemeFE%2Felement%2Fissues%2F3054\" rel=\"noopener noreferrer\" target=\"_blank\">地址</a>,大概思路:</p><ol><li data-list=\"ordered\"><span class=\"ql-ui\" contenteditable=\"false\"></span>先把默认主题文件中涉及到颜色的 CSS 值替换成关键词</li><li data-list=\"ordered\"><span class=\"ql-ui\" contenteditable=\"false\"></span>根据用户选择的主题色生成一系列对应的颜色值</li><li data-list=\"ordered\"><span class=\"ql-ui\" contenteditable=\"false\"></span>把关键词再换回刚刚生成的相应的颜色值</li><li data-list=\"ordered\"><span class=\"ql-ui\" contenteditable=\"false\"></span>直接在页面上加 style 标签，把生成的样式填进去</li></ol><p>我看完觉得真的还是有点复杂的。有没有简单的方案呢？ 让我们思考一下，让我们自己写动态换肤该怎么写呢？最常见的方法就是写两套主题，一套叫<code>day theme</code> ，一套叫<code>night theme</code>，<code>night theme</code>主题 都在一个<code>.night-theme</code>的命名空间下，我们动态的在<code>body</code>上<code>add .night-theme</code> ， <code>remove .night-theme</code>。这就是最简单的动态换肤。所以我们也能不能顺着这个思路，基于 element-ui 实现动态换肤呢？</p><p>首先我们下载官方通过的 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FElementUI%2Felement-theme\" rel=\"noopener noreferrer\" target=\"_blank\">Theme generator</a> ,一个专门用来生成Element主题的工具。按照文档，我们生成了需要的主题。</p><p><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/fe4fe211e42446d60da0~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\"></p><p>之后就是我们要做的事情了，将这个主题的每个元素外面包裹一个class 来做命名空间。 我们这里用到了<code>gulp-css-wrap</code>这个神器，轻轻松松就完成了我们想要的结果</p><p><br></p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">var path = require('path')</div><div class=\"ql-code-block\" data-language=\"plain\">var gulp = require('gulp')</div><div class=\"ql-code-block\" data-language=\"plain\">var cleanCSS = require('gulp-clean-css');</div><div class=\"ql-code-block\" data-language=\"plain\">var cssWrap = require('gulp-css-wrap');</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">var customThemeName='.custom-theme'</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">gulp.task('css-wrap', function() {</div><div class=\"ql-code-block\" data-language=\"plain\">  return gulp.src( path.resolve('./theme/index.css'))</div><div class=\"ql-code-block\" data-language=\"plain\">    .pipe(cssWrap({selector:customThemeName}))</div><div class=\"ql-code-block\" data-language=\"plain\">    .pipe(cleanCSS())</div><div class=\"ql-code-block\" data-language=\"plain\">    .pipe(gulp.dest('dist'));</div><div class=\"ql-code-block\" data-language=\"plain\">});</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">gulp.task('move-font', function() {</div><div class=\"ql-code-block\" data-language=\"plain\">  return gulp.src(['./theme/fonts/**']).pipe(gulp.dest('dist/fonts'));</div><div class=\"ql-code-block\" data-language=\"plain\">});</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">gulp.task('default',['css-wrap','move-font']);</div></div><p>这样就得到了一个以.custom-theme为命名空间的自定义主题了，之后我们在项目中引入主题</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">//main.js</div><div class=\"ql-code-block\" data-language=\"plain\">import 'assets/custom-theme/index.css'</div></div><p>我们在换肤的地方<code>toggleClass(document.body, 'custom-theme')</code>一直toggle body 的 class就可以了。我们就简单实现了动态换肤效果。</p><p><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/90538497cfec5aa965d3.gif~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\"></p><p>不过这种模式实现换肤也是有一个弊端的，它等于把这两个主题都打包在了项目里，如果你的项目主题需要七八种，这种模式就不适合了。我们就需要动态的加载css，下面就是最简单的动态添加css的例子，当然你可以封装一下，增加成功或者失败回调，判断是否加载过改资源等等就不展开了。</p><p><br></p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">var head = document.getElementsByTagName('HEAD').item(0);</div><div class=\"ql-code-block\" data-language=\"plain\">var style = document.createElement('link');</div><div class=\"ql-code-block\" data-language=\"plain\">style.href = 'style.css';</div><div class=\"ql-code-block\" data-language=\"plain\">style.rel = 'stylesheet';</div><div class=\"ql-code-block\" data-language=\"plain\">style.type = 'text/css';</div><div class=\"ql-code-block\" data-language=\"plain\">head.appendChild(style);</div></div><p><strong>更新(2017.12)</strong></p><p><code>element-ui</code> 官方更新了2.0版本，同时也提供了一个新的换肤思路。 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fpanjiachen.github.io%2Fvue-element-admin-site%2F%23%2Ftheme\" rel=\"noopener noreferrer\" target=\"_blank\">文档</a></p><h2>侧边栏</h2><p>这里又有谈一下导航栏的问题，本项目里的侧边栏是根据 router.js 配置的路由并且根据权限动态生成的，这样就省去了写一遍路由还要手动再写一次侧边栏这种麻烦事，但也遇到了一个问题，路由可能会有多层嵌套，很多人反馈自己的侧边栏会有三级，甚至还有五级的。所以重构了一下侧边栏，使用了递归组件，这样不管你多少级，都能愉快的显示了。<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FPanJiaChen%2Fvue-element-admin%2Ftree%2Fmaster%2Fsrc%2Fviews%2Flayout%2Fcomponents%2FSidebar\" rel=\"noopener noreferrer\" target=\"_blank\">代码</a></p><p><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/f9230d730d863040dc91~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\"></p><p><strong>侧边栏高亮问题:</strong> 很多人在群里问为什么自己的侧边栏不能跟着自己的路由高亮，其实很简单，element-ui官方已经给了default-active所以我们只要</p><p><br></p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">:default-active=\"$route.path\"</div></div><p>将<code>default-active</code>一直指向当前路由就可以了，就是这么简单。</p><p><strong>点击侧边栏 刷新当前路由</strong></p><p>在用 spa(单页面开发) 这种开发模式之前，大部分都是多页面后台，用户每次点击侧边栏都会重新请求这个页面，用户渐渐养成了点击侧边栏当前路由来刷新页面的习惯。但现在 spa 就不一样了，用户点击当前高亮的路由并不会刷新view，因为<code>vue-router</code>会拦截你的路由，它判断你<code>的url</code>并没有任何变化，所以它不会触发任何钩子或者是<code>view</code>的变化。<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue-router%2Fissues%2F296\" rel=\"noopener noreferrer\" target=\"_blank\">issue地址</a>，社区也对该问题展开了激烈讨论。</p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/99ccc1a31cc22a40c906~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\"></p><p>尤大本来也说要增加一个方法来强刷view，但后来他又改变了心意/(ㄒoㄒ)/~~。但需要就摆在这里，我们该怎么办呢？他说了不改变<code>current URL</code> 就不会触发任何东西，那我可不可以强行触发东西你？上有政策， 下有对策我们变着花来hack。方法也很简单，通过不断改变<code>url</code>的<code>query</code>来触发view的变化。我们监听侧边栏每个link 的 click事件，每次点击都给router push 一个不一样的query 来确保会重新刷新view。</p><p><br></p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">clickLink(path) {</div><div class=\"ql-code-block\" data-language=\"plain\">  this.$router.push({</div><div class=\"ql-code-block\" data-language=\"plain\">    path,</div><div class=\"ql-code-block\" data-language=\"plain\">    query: {</div><div class=\"ql-code-block\" data-language=\"plain\">      t: +new Date() //保证每次点击路由的query项都是不一样的，确保会重新刷新view</div><div class=\"ql-code-block\" data-language=\"plain\">    }</div><div class=\"ql-code-block\" data-language=\"plain\">  })</div><div class=\"ql-code-block\" data-language=\"plain\">}</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div></div><p>但这也有一个弊端就是 url 后面有一个很难看的 query 后缀如 <code>xxx.com/article/list?t=1496832345025</code>，但我司用户们表示能接受。。。只能暂时这样hack了，不知道大家有没有更好的方法，学习学习。</p><h2>Table</h2><p>经过好几个版本的迭代，element-ui 的table组件已经能满足大部分业务需求了。不过rowSpan colSpan表格行/列合并现在并不是支持(element-ui2.0版本之后开始支持)。官方对此功能的更新情况可以关注这个<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FElemeFE%2Felement%2Fissues%2F670\" rel=\"noopener noreferrer\" target=\"_blank\">issue</a>。</p><p>这里我着重讲一下table表格几个常用的业务形态。</p><h3>Table 拖拽排序</h3><p><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/5b0f91103d8e5121f34a.gif~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\"></p><p>这里主要是基于<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FRubaXa%2FSortable\" rel=\"noopener noreferrer\" target=\"_blank\">Sortable</a></p><p><br></p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">import Sortable from 'sortablejs'</div><div class=\"ql-code-block\" data-language=\"plain\">let el = document.querySelectorAll('.el-table__body-wrapper &gt; table &gt; tbody')[0]</div><div class=\"ql-code-block\" data-language=\"plain\">let sortable = Sortable.create(el)</div></div><p>在table mounted之后申明<code>Sortable.create(el)</code> table的每行tr就可以随意拖拽了，麻烦的目前我们的排序都是基于dom的，我们的数据层list并没有随之改变。所以我们就要手动的来管理我们的列表。</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">this.sortable = Sortable.create(el, {</div><div class=\"ql-code-block\" data-language=\"plain\">  onEnd: evt =&gt; { //监听end事件 手动维护列表</div><div class=\"ql-code-block\" data-language=\"plain\">    const tempIndex = this.newList.splice(evt.oldIndex, 1)[0];</div><div class=\"ql-code-block\" data-language=\"plain\">    this.newList.splice(evt.newIndex, 0, tempIndex);</div><div class=\"ql-code-block\" data-language=\"plain\">  }</div><div class=\"ql-code-block\" data-language=\"plain\">});</div></div><p>这样我们就简单的完成了 table 拖拽排序。这里如果不是基于 dom 的排序推荐使用<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSortableJS%2FVue.Draggable\" rel=\"noopener noreferrer\" target=\"_blank\">Vue.Draggable</a>。<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FPanJiaChen%2Fvue-element-admin%2Fblob%2Fmaster%2Fsrc%2Fviews%2Fexample%2Ftable%2FdragTable.vue\" rel=\"noopener noreferrer\" target=\"_blank\">完整代码</a></p><h3>Table 内联编辑</h3><p>table内联编辑也是一个常见的需求。</p><p><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/80da236c5cbc3b06e9f5.gif~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\"></p><p>其实也很简单，当我们拿到 list 数据之后先洗一下数据，每一条数据里面插入一个edit[ true or false ]判断符，来表示当前行是否处于编辑状态。之后就是通过v-show动态切换不同的相应view就可以了。<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FPanJiaChen%2Fvue-element-admin%2Fblob%2Fmaster%2Fsrc%2Fviews%2Fexample%2Ftable%2FinlineEditTable.vue\" rel=\"noopener noreferrer\" target=\"_blank\">完整代码</a></p><p><br></p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">&lt;el-table-column min-width=\"300px\" label=\"标题\"&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">  &lt;template scope=\"scope\"&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">    &lt;el-input v-show=\"scope.row.edit\" size=\"small\" v-model=\"scope.row.title\"&gt;&lt;/el-input&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">    &lt;span v-show=\"!scope.row.edit\"&gt;{{ scope.row.title }}&lt;/span&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">  &lt;/template&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">&lt;/el-table-column&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">&lt;el-table-column align=\"center\" label=\"编辑\" width=\"120\"&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">  &lt;template scope=\"scope\"&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">    &lt;el-button v-show='!scope.row.edit' type=\"primary\" @click='scope.row.edit=true' size=\"small\" icon=\"edit\"&gt;编辑&lt;/el-button&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">    &lt;el-button v-show='scope.row.edit' type=\"success\" @click='scope.row.edit=false' size=\"small\" icon=\"check\"&gt;完成&lt;/el-button&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">  &lt;/template&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">&lt;/el-table-column&gt;</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div></div><h3>Table 常见坑</h3><p>通过dialog来编辑，新建，删除table的元素这种业务场景相对于前面说的两种更加的常见。而且也有不少的小坑。 首先我们要明确一个点 vue 是一个MVVM框架，我们传统写代码是命令式编程，拿到table这个dom之后就是命令式对dom增删改。而我们现在用声明式编程，只用关注data的变化就好了，所以我们这里的增删改都是基于list这个数组来的。这里我们还要明确一点<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Flist.html%23%25E6%25B3%25A8%25E6%2584%258F%25E4%25BA%258B%25E9%25A1%25B9\" rel=\"noopener noreferrer\" target=\"_blank\">vue 列表渲染注意事项</a></p><blockquote>由于 JavaScript 的限制， Vue 不能检测以下变动的数组： * 当你利用索引直接设置一个项时，例如： vm.items[indexOfItem] = newValue</blockquote><p>所以我们想改变table中第一条数据的值，通过<code>this.list[0]=newValue</code>这样是不会生效的。</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">解决方案：</div><div class=\"ql-code-block\" data-language=\"plain\">// Array.prototype.splice`</div><div class=\"ql-code-block\" data-language=\"plain\">example1.items.splice(indexOfItem, 1, newValue)</div></div><p>所以我们可以通过</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">//添加数据</div><div class=\"ql-code-block\" data-language=\"plain\">this.list.unshift(this.temp);</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">//删除数据 </div><div class=\"ql-code-block\" data-language=\"plain\">const index = this.list.indexOf(row); //找到要删除数据在list中的位置</div><div class=\"ql-code-block\" data-language=\"plain\">this.list.splice(index, 1); //通过splice 删除数据</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">//修改数据</div><div class=\"ql-code-block\" data-language=\"plain\">const index = this.list.indexOf(row); //找到修改的数据在list中的位置</div><div class=\"ql-code-block\" data-language=\"plain\">this.list.splice(index, 1,this.updatedData); //通过splice 替换数据 触发视图更新</div></div><p>这样我们就完成了对table的增删改操作，列表view也自动响应发生了变化。这里在修改数据的时候还有一个小坑<strong>需要主要</strong>。 当我们拿到需要修改行的数据时候不能直接将它直接赋值给dialog，不然会发生下面的问题。</p><p><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/a7d80d91001f15b7f5be.gif~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\"></p><p>如上图所示，我们在dialog里面改变状态的时候，遮罩下面的table里面该行的状态也在那里跟着一只变化着。原因想必大家都猜到了。赋值的数据是一个objec引用类型共享一个内存区域的。所以我们就不能直接连等复制，需要重新指向一个新的引用，方案如下：</p><p><br></p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">//赋值对象是一个obj</div><div class=\"ql-code-block\" data-language=\"plain\">this.objData=Object.assign({}, row) //这样就不会共用同一个对象</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">//数组我们也有一个巧妙的防范</div><div class=\"ql-code-block\" data-language=\"plain\">newArray = oldArray.slice(); //slice会clone返回一个新数组</div></div><h3>Tabs</h3><p>tab在后台项目中也比较常用的。假设我们有四个tab选项，每个tab都会向后端请求数据，但我们希望一开始只会请求当前的tab数据，而且tab来回切换的时候不会重复请求，只会实例化一次。首先我们想到的就是用<code>v-if</code> 这样的确能做到一开始不会挂载后面的tab，但有一个问题，每次点击这个tab组件都会重新挂载一次，这是我们不想看到的，这时候我们就可以用到<code>&lt;keep-alive&gt;</code>了。</p><blockquote>keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。 它是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</blockquote><p>所以我们就可以这样写tabs了</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">&lt;el-tabs v-model=\"activeTab\"&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">  &lt;el-tab-pane label=\"简介及公告\" name=\"announcement\"&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">    &lt;announcement /&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">  &lt;/el-tab-pane&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">  &lt;el-tab-pane label=\"资讯\" name=\"information\"&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">    &lt;keep-alive&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">      &lt;information v-if=\"activeTab=='information'\" /&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">    &lt;/keep-alive&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">  &lt;/el-tab-pane&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">  &lt;el-tab-pane label=\"直播流配置\" name=\"stream\"&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">    &lt;keep-alive&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">      &lt;stream v-if=\"activeTab=='stream'\" /&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">    &lt;/keep-alive&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">  &lt;/el-tab-pane&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">&lt;/el-tabs&gt;</div></div><h2>Select 选择器</h2><p>Select 选择器直接使用没有什么太多问题，但很多时候我们需要通过Select来回显一些数据，当我们<code>&lt;el-select v-model=\"objValue\"&gt;</code> select 绑定一个obj value回显就会很蛋疼了，它要求必须保持同一个引用<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FElemeFE%2Felement%2Fissues%2F1780\" rel=\"noopener noreferrer\" target=\"_blank\">issue</a>。这就意味着，我们回显数据的时候想先要找到该数据在arr中的位置，再回塞：<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FElemeFE%2Felement%2Fissues%2F2479%2F\" rel=\"noopener noreferrer\" target=\"_blank\">demo</a>。这还不是在远程搜索的情况下，如果是远程搜索的情况还要当疼。 这里推荐一下<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmonterail%2Fvue-multiselect\" rel=\"noopener noreferrer\" target=\"_blank\">vue-multiselect</a> 它能完美的解决前面Element select的问题。目前也是vue component 中比较好用的一个，ui也非常的好看，建议大家可以尝试性用一下，真的非常的不错。</p><h2>Upload 上传</h2><p>Upload本身没什么好说的，文档写的蛮清楚了。这里主要说一下怎么将Upload组件和七牛直传结合在一起。</p><p>这里我们选择api直传的方式，就是我们首先要通过后端(go,node,php都可以)<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.qiniu.com%2Fsdk%23official-sdk\" rel=\"noopener noreferrer\" target=\"_blank\">文档</a>生成七牛上传必要的token(上传凭证)和key(资源的最终名称)。 所以现在只要想办法讲token和key塞进post请求里面就可以了，好在官方也提供了这个方法。</p><p><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/203eca2ac0845e7376db~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\"></p><p>。但怎么才能先异步的拿到token再将它塞入请求里呢？</p><p><br></p><p><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/2b136a93af9689131d6c~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\"></p><p>这时候我们又发现了before-upload\t这个钩子还支持promise简直合我们的心意。 但我们写着写着怎样才能动态的改变之前的dataObj呢？通过看源码发现我们可以_self._data这样子拿到我们想要的数据。<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FPanJiaChen%2Fvue-element-admin%2Fblob%2Fmaster%2Fsrc%2Fviews%2Fqiniu%2Fupload.vue\" rel=\"noopener noreferrer\" target=\"_blank\">线上代码</a></p><p><br></p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">&lt;template&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">  &lt;el-upload</div><div class=\"ql-code-block\" data-language=\"plain\">      action=\"https://upload.qbox.me\"</div><div class=\"ql-code-block\" data-language=\"plain\">      :data=\"dataObj\"</div><div class=\"ql-code-block\" data-language=\"plain\">      drag</div><div class=\"ql-code-block\" data-language=\"plain\">      :multiple=\"true\"</div><div class=\"ql-code-block\" data-language=\"plain\">      :before-upload=\"beforeUpload\"&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">    &lt;i class=\"el-icon-upload\"&gt;&lt;/i&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">    &lt;div class=\"el-upload__text\"&gt;将文件拖到此处，或&lt;em&gt;点击上传&lt;/em&gt;&lt;/div&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">  &lt;/el-upload&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">&lt;/template&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">&lt;script&gt;</div><div class=\"ql-code-block\" data-language=\"plain\">    import { getToken } from 'api/qiniu'; // 获取七牛token 后端通过Access Key,Secret Key,bucket等生成token</div><div class=\"ql-code-block\" data-language=\"plain\">    // 七牛官方sdk https://developer.qiniu.com/sdk#official-sdk</div><div class=\"ql-code-block\" data-language=\"plain\">    export default{</div><div class=\"ql-code-block\" data-language=\"plain\">      data() {</div><div class=\"ql-code-block\" data-language=\"plain\">        return {</div><div class=\"ql-code-block\" data-language=\"plain\">          dataObj: { token: '', key: '' },</div><div class=\"ql-code-block\" data-language=\"plain\">          image_uri: [],</div><div class=\"ql-code-block\" data-language=\"plain\">          fileList: []</div><div class=\"ql-code-block\" data-language=\"plain\">        }</div><div class=\"ql-code-block\" data-language=\"plain\">      },</div><div class=\"ql-code-block\" data-language=\"plain\">      methods: {</div><div class=\"ql-code-block\" data-language=\"plain\">        beforeUpload() {</div><div class=\"ql-code-block\" data-language=\"plain\">          const _self = this;</div><div class=\"ql-code-block\" data-language=\"plain\">          return new Promise((resolve, reject) =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">            getToken().then(response =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">              const key = response.data.qiniu_key;</div><div class=\"ql-code-block\" data-language=\"plain\">              const token = response.data.qiniu_token;</div><div class=\"ql-code-block\" data-language=\"plain\">              _self._data.dataObj.token = token;</div><div class=\"ql-code-block\" data-language=\"plain\">              _self._data.dataObj.key = key;</div><div class=\"ql-code-block\" data-language=\"plain\">              resolve(true);</div><div class=\"ql-code-block\" data-language=\"plain\">            }).catch(err =&gt; {</div><div class=\"ql-code-block\" data-language=\"plain\">              console.log(err)</div><div class=\"ql-code-block\" data-language=\"plain\">              reject(false)</div><div class=\"ql-code-block\" data-language=\"plain\">            });</div><div class=\"ql-code-block\" data-language=\"plain\">          });</div><div class=\"ql-code-block\" data-language=\"plain\">        }</div><div class=\"ql-code-block\" data-language=\"plain\">      }</div><div class=\"ql-code-block\" data-language=\"plain\">    }</div><div class=\"ql-code-block\" data-language=\"plain\">&lt;/script&gt;</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div></div><h3>jsx</h3><p>在使用Element的时候，官方提供了很多可以自己写render function的地方，但由于Element内部都是用jsx 写render function的，所以demo也都是jsx，但很多人自己项目中其实是没有安装的，导致报错。但说真的用createElement裸写render 函数还是有些蛋疼。我们要用jsx，首先要安装 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fbabel-plugin-transform-vue-jsx\" rel=\"noopener noreferrer\" target=\"_blank\">babel-plugin-transform-vue-jsx</a> 安装方法如下：</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">npm install\\</div><div class=\"ql-code-block\" data-language=\"plain\">  babel-plugin-syntax-jsx\\</div><div class=\"ql-code-block\" data-language=\"plain\">  babel-plugin-transform-vue-jsx\\</div><div class=\"ql-code-block\" data-language=\"plain\">  babel-helper-vue-jsx-merge-props\\</div><div class=\"ql-code-block\" data-language=\"plain\">  babel-preset-es2015\\</div><div class=\"ql-code-block\" data-language=\"plain\">  --save-dev</div><div class=\"ql-code-block\" data-language=\"plain\">  </div></div><p>.babelrc:文件</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">{</div><div class=\"ql-code-block\" data-language=\"plain\">  \"presets\": [\"es2015\"],</div><div class=\"ql-code-block\" data-language=\"plain\">  \"plugins\": [\"transform-vue-jsx\"]</div><div class=\"ql-code-block\" data-language=\"plain\">}</div></div><p>这样我们就可以愉快的使用 jsx 写render function了。</p><h2>element 常见问题</h2><p>**click事件不触发问题：**一直有人在群里问<code>&lt;el-input @click=\"handlenClick\"&gt;Click Me&lt;/el-input&gt;</code>怎么不触发click事件，虽然element文档还有完善的空间但这种问题大家还真要自己好好认真看一下官方的<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FElemeFE%2Felement%2Fblob%2Fdev%2FFAQ.md\" rel=\"noopener noreferrer\" target=\"_blank\">FAQ</a>了。</p><blockquote>官方说明了所有的原生事件必须添加 .native 修饰符。</blockquote><p><strong>修改element样式问题：</strong> 用ui组件总免不了需要对它做一些个性化定制的需求，所以我们就要覆盖element的一些样式。 首先我们要了解一下vue scoped是什么，很多人非常喜欢用scoped，妈妈再也不用担心样式冲突问题了，其实scoped也没有很神秘的，它就是基于PostCss的，加了一个作用局的概念。</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">//编译前</div><div class=\"ql-code-block\" data-language=\"plain\">.example {</div><div class=\"ql-code-block\" data-language=\"plain\">  color: red;</div><div class=\"ql-code-block\" data-language=\"plain\">}</div><div class=\"ql-code-block\" data-language=\"plain\">//编译后</div><div class=\"ql-code-block\" data-language=\"plain\">.example[_v-f3f3eg9] {</div><div class=\"ql-code-block\" data-language=\"plain\">  color: red;</div><div class=\"ql-code-block\" data-language=\"plain\">}</div></div><p>它和我们传统的命名空间的方法避免css冲突没有什么本质性的区别。 现在我们来说说怎么覆盖element-ui样式。由于element-ui的样式我们是在全局引入的，所以你想在某个view里面覆盖它的样式就不能加scoped，但你又想只覆盖这个页面的element样式，你就可在它的父级加一个class，以用命名空间来解决问题。</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">.aritle-page{ //你的命名空间</div><div class=\"ql-code-block\" data-language=\"plain\">    .el-tag { //element-ui 元素</div><div class=\"ql-code-block\" data-language=\"plain\">      margin-right: 0px;</div><div class=\"ql-code-block\" data-language=\"plain\">    }</div><div class=\"ql-code-block\" data-language=\"plain\">}</div></div><p>建议向楼主一样专门建一个scss文件里专门自定义element-ui的各种样式。<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FPanJiaChen%2Fvue-element-admin%2Fblob%2Fmaster%2Fsrc%2Fstyles%2Felement-ui.scss\" rel=\"noopener noreferrer\" target=\"_blank\">线上代码</a></p><p>其它关于element相关的东西真的没有什么好说的了，人家文档和源码就放在那里，有问题就去看文档，再去issue里找找，再去看看源码，大部分问题都能解决了。给一个诀窍其实大部分诡异的问题都可以通过加一个key或者 Vue.nextTick来解决。。</p><h2>富文本</h2><p>管理后台富文本也是一个非常重要的功能，楼主在这里也踩了不少的坑。楼主在项目里最终选择了 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftinymce%2Ftinymce\" rel=\"noopener noreferrer\" target=\"_blank\">tinymce</a></p><p>这里在简述一下推荐使用tinymce的原因：tinymce 是一家老牌做富文本的公司(这里也推荐 ckeditor，也是一家一直做富文本的公司，新版本很不错)，它的产品经受了市场的认可，不管是文档还是配置的自由度都很好。在使用富文本的时候有一点也很关键就是复制格式化，之前在用一款韩国人做的富文本summernote被它的格式化坑的死去活来，但 tinymce 的去格式化相当的好，它还有一个增值项目就是powerpaste,那是无比的强大，支持从word里面复制各种东西，都不会有问题。富文本还有一点也很关键，就是拓展性。楼主用tinymce写了好几个插件，学习成本和容易度都不错，很方便拓展。最后一点就是文档很完善，基本你想得到的配置项，它都有。tinymce也支持按需加载，你可以通过它官方的build页定制自己需要的plugins。 我再来分析一下市面上其它的一些富文本：</p><ol><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span><strong><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsummernote%2Fsummernote\" rel=\"noopener noreferrer\" target=\"_blank\">summernote</a></strong> 先来说一个我绝对不推荐的富文本。这是一个韩国人开源的富文本(当然不推荐的理由不是因为这个)，它对很多富文本业界公认的默认行为理解是反起到而行的，而且只为用了一个dialog的功能，引入了boostrap，一堆人抗议就是不改。格式化也是差劲。。反正不要用！不要用！不要用！</li><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span><strong><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgaletahub%2Fckeditor\" rel=\"noopener noreferrer\" target=\"_blank\">ckeditor</a></strong> ckeditor也是一家老牌做富文本的公司，楼主旧版后台用的就是这个，今年也出了5.0版本，ui也变美观了不少，相当的不错，而且它号称是插件最丰富的富文本了。推荐大家也可以试用一下。</li><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span><strong><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fquilljs%2Fquill\" rel=\"noopener noreferrer\" target=\"_blank\">quill</a></strong> 也是一个非常火的富文本，长相很不错。基于它写插件也很简单，api设计也很简单。楼主不选择它的原因是它对图片的各种操作不友善，而且很难改。如果对图片没什么操作的用户，推荐使用。</li><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span><strong><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyabwe%2Fmedium-editor\" rel=\"noopener noreferrer\" target=\"_blank\">medium-</a><em><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyabwe%2Fmedium-editor\" rel=\"noopener noreferrer\" target=\"_blank\">editor</a></em></strong> 大名鼎鼎的medium的富文本(非官方出品)，但完成度还是不很不错，拓展性也不错。不过我觉得大部分用户还是会不习惯medium这种写作方式的。</li><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span><strong><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fneilj%2FSquire\" rel=\"noopener noreferrer\" target=\"_blank\">Squire</a></strong> 一个比较轻量的富文本，压缩完才11.5kb，相对于其它的富文本来说是非常的小了，推荐功能不复杂的建议使用。</li><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span><strong><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwangfupeng1988%2FwangEditor\" rel=\"noopener noreferrer\" target=\"_blank\">wangEditor</a></strong> 一个国人写的富文本，用过感觉还是不错的。不过毕竟是个人的，不像专门公司做富文本的，配置型和丰富性不足。前端几大禁忌就有富文本 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F38699645\" rel=\"noopener noreferrer\" target=\"_blank\">为什么都说富文本编辑器是天坑?</a>，不过个人能做成这样子很不容易了。</li><li data-list=\"bullet\"><span class=\"ql-ui\" contenteditable=\"false\"></span><strong><a href=\"https://link.juejin.cn?target=http%3A%2F%2Fueditor.baidu.com%2Fwebsite%2Findex.html\" rel=\"noopener noreferrer\" target=\"_blank\">百度UEditor</a></strong> 没有深入使用过，只在一个angular1X的项目简单用过，不过说着的ui真的不好看，不符合当今审美了，官方也已经很久没跟新过了。</li></ol><p>楼主列举了很多富文本但并没有列举任何 vue 相关的富文本，主要是因为富文本真的比想象中复杂，在前面的文章里也说过了，其实用 vue 封装组件很方便的，没必要去用人家封装的东西什么vue-quill vue-editor这种都只是简单包了一层，没什么难度的。还不如自己来封装，灵活性可控性更强一点。还有一点基于 vue 真没什么好的富文本，不像 react 有 facebook 出的 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Fdraft-js\" rel=\"noopener noreferrer\" target=\"_blank\">draft-js</a>，ory 出的 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fory%2Feditor\" rel=\"noopener noreferrer\" target=\"_blank\">editor</a>，这种大厂出的产品。</p><p>当然你也可以选择一些付费的富文本编辑器，作者自己公司里面有一个项目就使用了 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.froala.com%2Fwysiwyg-editor\" rel=\"noopener noreferrer\" target=\"_blank\">froala-editor</a> 这款编辑器。不管是美观和易用性都是不错的，公司买的是专业版，一年也就 <code>$349</code> ，价格也是很合理的，但其实省去的程序员开发陈本可能远不止这个价钱。</p><h2>Tinymce</h2><p>这里来简单讲一下在自己项目中使用 <code>Tinymce</code> 的方法。</p><blockquote>由于目前使用 npm 安装 <code>Tinymce</code> 方法比较负责复杂而且还有一些问题(日后可能会采用该模式)。:space_invader:</blockquote><p>目前采用全局引用的方式。代码地址：<code>static/tinymce</code> static目录下的文件不会被打包, 在 index.html 中引入。</p><p><strong>使用</strong> 由于富文本不适合双向数据流，所以只会 watch 传入富文本的内容一次变化，只会就不会再监听了，如果之后还有改变富文本内容的需求。 可以通过 <code>this.refs.xxx.setContent()</code> 来设置</p><p>源码也很简单，有任何别的需求都可以在 <code>@/components/Tinymce/index.vue</code> 中自行修改。</p><h2>Markdown</h2><p>markdown 我们这里选用了 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparksuite%2Fsimplemde-markdown-editor\" rel=\"noopener noreferrer\" target=\"_blank\">simplemde-markdown-editor</a> ，简单的用vue封装了一下<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FF-loat%2Fvue-simplemde%2Fblob%2Fmaster%2Fmarkdown-editor.vue\" rel=\"noopener noreferrer\" target=\"_blank\">地址</a>,如果需求方能接受 markdown 就一定要用 markdown，坑真心会比富文本少很多。这里我们用markdown做了编辑器，还需要一个能解析的的东西。可以你传给后端让后端帮你转化，也可以前端自己来，这里推荐一个转化库<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fshowdownjs%2Fshowdown\" rel=\"noopener noreferrer\" target=\"_blank\">showdown</a>。使用方法：</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">import('showdown').then(showdown =&gt; { //用了 Dynamic import</div><div class=\"ql-code-block\" data-language=\"plain\">  const converter = new showdown.Converter();//初始化</div><div class=\"ql-code-block\" data-language=\"plain\">  this.html = converter.makeHtml(this.content)//转化</div><div class=\"ql-code-block\" data-language=\"plain\">})</div></div><p>用法也很简单两行代码就完成了markdown to html，当然它还有很多个性画的配置，大家有需求自行研究吧。</p><p><br></p><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/6d14e79260c1f71d4be5.gif~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\"></p><p><br></p><h2>导出excel</h2><p>这里先明确一点，如果你的业务需求对导出文件的格式没有什么要求，不建议导出成xlsx格式的，直接导出成csv的就好了，真的会简单很多。创建一个a标签，写上<code>data:text/csv;charset=utf-8</code>头，再把数据塞进去，<code>encodeURI(csvContent)</code>一下就好了，详情就不展开了，大家可以借鉴这个<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F14964035%2Fhow-to-export-javascript-array-info-to-csv-on-client-side\" rel=\"noopener noreferrer\" target=\"_blank\">stackoverflow回答</a>。 我们重点说一下转xlsx，我们这里用到了<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSheetJS%2Fjs-xlsx\" rel=\"noopener noreferrer\" target=\"_blank\">js-xlsx</a>，一个功能很强大excel处理库，只是下载各种格式excel，还支持读取excel，但上手难度也非常大，相当的复杂，其中涉及不少二进制相关的东西。不过好在官方给了我们一个<a href=\"https://link.juejin.cn?target=http%3A%2F%2Fsheetjs.com%2Fdemos%2Fwritexlsx.html\" rel=\"noopener noreferrer\" target=\"_blank\">demo例子</a>,我们写不来还抄不来么，于是我们就借鉴官方的例子来改造了一下，具体原理就不详细说了，真的很复杂。。。 重点是我们怎么使用！首先我们封装一个<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FPanJiaChen%2Fvue-element-admin%2Fblob%2Fmaster%2Fsrc%2Fvendor%2FExport2Excel.js\" rel=\"noopener noreferrer\" target=\"_blank\">Export2Excel.js</a>， 它又依赖三个库</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">require('script-loader!file-saver'); //保存文件用</div><div class=\"ql-code-block\" data-language=\"plain\">require('script-loader!vendor/Blob'); //转二进制用</div><div class=\"ql-code-block\" data-language=\"plain\">require('script-loader!xlsx/dist/xlsx.core.min'); //xlsx核心</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\">由于这几个文件不支持import引入，所以我们需要`script-loader`来将他们挂载到全局环境下。</div></div><p>它暴露了两个接口<code>export_table_to_excel</code>和<code>export_json_to_excel</code>,我们常用<code>export_json_to_excel</code>因为更加的可控一点，我们可以自由的洗数据。</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">handleDownload() {</div><div class=\"ql-code-block\" data-language=\"plain\">  require.ensure([], () =&gt; { // 用 webpack Code Splitting xlsl还是很大的</div><div class=\"ql-code-block\" data-language=\"plain\">    const { export_json_to_excel } = require('vendor/Export2Excel');</div><div class=\"ql-code-block\" data-language=\"plain\">    const tHeader = ['序号', '文章标题', '作者', '阅读数', '发布时间']; // excel 表格头</div><div class=\"ql-code-block\" data-language=\"plain\">    const filterVal = ['id', 'title', 'author', 'pageviews', 'display_time'];</div><div class=\"ql-code-block\" data-language=\"plain\">    const list = this.list;</div><div class=\"ql-code-block\" data-language=\"plain\">    const data = this.formatJson(filterVal, list); // 自行洗数据 按序排序的一个array数组</div><div class=\"ql-code-block\" data-language=\"plain\">    export_json_to_excel(tHeader, data, '列表excel');</div><div class=\"ql-code-block\" data-language=\"plain\">  })</div><div class=\"ql-code-block\" data-language=\"plain\">}，</div><div class=\"ql-code-block\" data-language=\"plain\">formatJson(filterVal, jsonData) {</div><div class=\"ql-code-block\" data-language=\"plain\">  return jsonData.map(v =&gt; filterVal.map(j =&gt; v[j]))</div><div class=\"ql-code-block\" data-language=\"plain\">}</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div></div><p><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FPanJiaChen%2Fvue-element-admin%2Fblob%2Fmaster%2Fsrc%2Fviews%2Fexcel%2Findex.vue\" rel=\"noopener noreferrer\" target=\"_blank\">完整显示线上代码</a></p><h2>ECharts</h2><p>管理后台图表也是常见得需求。这里图表就只推荐ECharts，功能齐全，社区demo也丰富<a href=\"https://link.juejin.cn?target=http%3A%2F%2Fgallery.echartsjs.com%2Fexplore.html\" rel=\"noopener noreferrer\" target=\"_blank\">gallery</a>。我还是那个观点，大部分插件建议大家还是自己用vue来包装就好了，真的很简单。ECharts支持webpack引入，图省事可以将ECharts整个引入<code>var echarts = require('echarts');</code>不过ECharts还是不小的，我们大部分情况只是用到很少一部分功能，我平时习惯于按需引入的。</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">// 引入 ECharts 主模块</div><div class=\"ql-code-block\" data-language=\"plain\">var echarts = require('echarts/lib/echarts');</div><div class=\"ql-code-block\" data-language=\"plain\">// 引入柱状图</div><div class=\"ql-code-block\" data-language=\"plain\">require('echarts/lib/chart/bar');</div><div class=\"ql-code-block\" data-language=\"plain\">// 引入提示框和标题组件</div><div class=\"ql-code-block\" data-language=\"plain\">require('echarts/lib/component/tooltip');</div><div class=\"ql-code-block\" data-language=\"plain\">require('echarts/lib/component/title');</div></div><p><a href=\"https://link.juejin.cn?target=http%3A%2F%2Fecharts.baidu.com%2Ftutorial.html%23%25E5%259C%25A8%2520webpack%2520%25E4%25B8%25AD%25E4%25BD%25BF%25E7%2594%25A8%2520ECharts\" rel=\"noopener noreferrer\" target=\"_blank\">webpack中使用ECharts文档</a> <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fecomfe%2Fecharts%2Fblob%2Fmaster%2Findex.js\" rel=\"noopener noreferrer\" target=\"_blank\">ECharts按需引入模块文档</a> 接下来我们就要在vue中声明初始化ECharts了。因为ECharts初始化必须绑定dom，所以我们只能在vue的mounted生命周期里初始化。</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">mounted() {</div><div class=\"ql-code-block\" data-language=\"plain\">  this.initCharts();</div><div class=\"ql-code-block\" data-language=\"plain\">},</div><div class=\"ql-code-block\" data-language=\"plain\">methods: {</div><div class=\"ql-code-block\" data-language=\"plain\">  this.initCharts() {</div><div class=\"ql-code-block\" data-language=\"plain\">    this.chart = echarts.init(this.$el);</div><div class=\"ql-code-block\" data-language=\"plain\">    this.setOptions();</div><div class=\"ql-code-block\" data-language=\"plain\">  },</div><div class=\"ql-code-block\" data-language=\"plain\">  setOptions() {</div><div class=\"ql-code-block\" data-language=\"plain\">    this.chart.setOption({</div><div class=\"ql-code-block\" data-language=\"plain\">      title: {</div><div class=\"ql-code-block\" data-language=\"plain\">        text: 'ECharts 入门示例'</div><div class=\"ql-code-block\" data-language=\"plain\">      },</div><div class=\"ql-code-block\" data-language=\"plain\">      tooltip: {},</div><div class=\"ql-code-block\" data-language=\"plain\">      xAxis: {</div><div class=\"ql-code-block\" data-language=\"plain\">        data: [\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"]</div><div class=\"ql-code-block\" data-language=\"plain\">      },</div><div class=\"ql-code-block\" data-language=\"plain\">      yAxis: {},</div><div class=\"ql-code-block\" data-language=\"plain\">      series: [{</div><div class=\"ql-code-block\" data-language=\"plain\">        name: '销量',</div><div class=\"ql-code-block\" data-language=\"plain\">        type: 'bar',</div><div class=\"ql-code-block\" data-language=\"plain\">        data: [5, 20, 36, 10, 10, 20]</div><div class=\"ql-code-block\" data-language=\"plain\">      }]</div><div class=\"ql-code-block\" data-language=\"plain\">    })</div><div class=\"ql-code-block\" data-language=\"plain\">  }</div><div class=\"ql-code-block\" data-language=\"plain\">}</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div></div><p>就这样简单，ECharts就配置完成了，这时候你想说我的data是远程获取的，或者说我动态改变ECharts的配置该怎么办呢？我们可以通过watch来触发setOptions方法</p><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">//第一种 watch options变化 利用vue的深度 watcher，options一有变化就重新setOption</div><div class=\"ql-code-block\" data-language=\"plain\">watch: {</div><div class=\"ql-code-block\" data-language=\"plain\">  options: {</div><div class=\"ql-code-block\" data-language=\"plain\">    handler(options) {</div><div class=\"ql-code-block\" data-language=\"plain\">      this.chart.setOption(this.options)</div><div class=\"ql-code-block\" data-language=\"plain\">    },</div><div class=\"ql-code-block\" data-language=\"plain\">    deep: true</div><div class=\"ql-code-block\" data-language=\"plain\">  },</div><div class=\"ql-code-block\" data-language=\"plain\">}</div><div class=\"ql-code-block\" data-language=\"plain\">//第二种 只watch 数据的变化 只有数据变化时触发ECharts</div><div class=\"ql-code-block\" data-language=\"plain\">watch: {</div><div class=\"ql-code-block\" data-language=\"plain\">  seriesData(val) {</div><div class=\"ql-code-block\" data-language=\"plain\">    this.setOptions({series:val})</div><div class=\"ql-code-block\" data-language=\"plain\">  }</div><div class=\"ql-code-block\" data-language=\"plain\">}</div><div class=\"ql-code-block\" data-language=\"plain\"><br></div></div><p>其实都差不多，还是要结合自己业务来封装。后面就和平时使用ECharts没有什么区别了。题外话ECharts的可配置项真心多，大家使用的时候可能要花一点时间了解它的api的。知乎有个问题：百度还有什么比较良心的产品？答案：ECharts，可见ECharts的强大与好用。</p><h2>相同component 不同参数</h2><p><strong>创建与编辑</strong> 其实后台创建与编辑功能是最常见的了，它区别去前台项目多了改的需求，但大部分创建页面与编辑页面字段和ui几乎是一样的，所以我们准备公用一个component来对应不同的页面。有两种常见的方法，来区别创建与编辑。</p><ol><li data-list=\"ordered\"><span class=\"ql-ui\" contenteditable=\"false\"></span>通过路由path的方式 这种方式最简单暴力，我自己的项目中使用这种方式，通过约定路径中出现'edit'就判断为编辑模式。比较省力和方便，不过这是要在大家写路径的时候都按照规范来写的前提下。</li><li data-list=\"ordered\"><span class=\"ql-ui\" contenteditable=\"false\"></span>通过meta来区分 比较推荐这种方式来区分。</li><li data-list=\"ordered\"><span class=\"ql-ui\" contenteditable=\"false\"></span><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/leancloud-assets/25969342df96a2000ec6~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\"></li></ol><div class=\"ql-code-block-container\" spellcheck=\"false\"><div class=\"ql-code-block\" data-language=\"plain\"><br></div><div class=\"ql-code-block\" data-language=\"plain\"> 代码解读</div><div class=\"ql-code-block\" data-language=\"plain\">复制代码</div><div class=\"ql-code-block\" data-language=\"plain\">computed: {</div><div class=\"ql-code-block\" data-language=\"plain\">  isEdit() {</div><div class=\"ql-code-block\" data-language=\"plain\">    return this.$route.meta.isEdit // 根据meta判断</div><div class=\"ql-code-block\" data-language=\"plain\">    // return this.$route.path.indexOf('edit') !== -1 // 根据路由判断</div><div class=\"ql-code-block\" data-language=\"plain\">  }</div><div class=\"ql-code-block\" data-language=\"plain\">}，</div><div class=\"ql-code-block\" data-language=\"plain\">created() {</div><div class=\"ql-code-block\" data-language=\"plain\">  if (this.isEdit) { </div><div class=\"ql-code-block\" data-language=\"plain\">    this.fetchData();</div><div class=\"ql-code-block\" data-language=\"plain\">  }</div><div class=\"ql-code-block\" data-language=\"plain\">},</div></div><p>就这样简单的实现了多路由复用了一个component，其实不只是创建和编辑可以这样用，如两个列表的一模一样，只是一个是内部文章另一个是调取外部文章都能复用组件，通过meta的方式来判断调取不同的接口。</p><p><br></p>",
			"tags": ["JavaScript", "异步编程", "Promise"],
			"categories": ["编程", "技术"],
			"featuredImage": "/images/posts/async-programming.png",
			"readTime": "7分钟"
		}
		
	]
}